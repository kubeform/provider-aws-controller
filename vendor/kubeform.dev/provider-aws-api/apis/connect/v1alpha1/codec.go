/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BotAssociationSpecLexBot{}).Type1()):                               BotAssociationSpecLexBotCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigEndTime{}).Type1()):                      HoursOfOperationSpecConfigEndTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigStartTime{}).Type1()):                    HoursOfOperationSpecConfigStartTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(QueueSpecOutboundCallerConfig{}).Type1()):                          QueueSpecOutboundCallerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(QuickConnectSpecQuickConnectConfig{}).Type1()):                     QuickConnectSpecQuickConnectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructure{}).Type1()):           UserHierarchyStructureSpecHierarchyStructureCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFive{}).Type1()):  UserHierarchyStructureSpecHierarchyStructureLevelFiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFour{}).Type1()):  UserHierarchyStructureSpecHierarchyStructureLevelFourCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelOne{}).Type1()):   UserHierarchyStructureSpecHierarchyStructureLevelOneCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelThree{}).Type1()): UserHierarchyStructureSpecHierarchyStructureLevelThreeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelTwo{}).Type1()):   UserHierarchyStructureSpecHierarchyStructureLevelTwoCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BotAssociationSpecLexBot{}).Type1()):                               BotAssociationSpecLexBotCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigEndTime{}).Type1()):                      HoursOfOperationSpecConfigEndTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigStartTime{}).Type1()):                    HoursOfOperationSpecConfigStartTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(QueueSpecOutboundCallerConfig{}).Type1()):                          QueueSpecOutboundCallerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(QuickConnectSpecQuickConnectConfig{}).Type1()):                     QuickConnectSpecQuickConnectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructure{}).Type1()):           UserHierarchyStructureSpecHierarchyStructureCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFive{}).Type1()):  UserHierarchyStructureSpecHierarchyStructureLevelFiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFour{}).Type1()):  UserHierarchyStructureSpecHierarchyStructureLevelFourCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelOne{}).Type1()):   UserHierarchyStructureSpecHierarchyStructureLevelOneCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelThree{}).Type1()): UserHierarchyStructureSpecHierarchyStructureLevelThreeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelTwo{}).Type1()):   UserHierarchyStructureSpecHierarchyStructureLevelTwoCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type BotAssociationSpecLexBotCodec struct {
}

func (BotAssociationSpecLexBotCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BotAssociationSpecLexBot)(ptr) == nil
}

func (BotAssociationSpecLexBotCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BotAssociationSpecLexBot)(ptr)
	var objs []BotAssociationSpecLexBot
	if obj != nil {
		objs = []BotAssociationSpecLexBot{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BotAssociationSpecLexBot{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BotAssociationSpecLexBotCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BotAssociationSpecLexBot)(ptr) = BotAssociationSpecLexBot{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BotAssociationSpecLexBot

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BotAssociationSpecLexBot{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BotAssociationSpecLexBot)(ptr) = objs[0]
			} else {
				*(*BotAssociationSpecLexBot)(ptr) = BotAssociationSpecLexBot{}
			}
		} else {
			*(*BotAssociationSpecLexBot)(ptr) = BotAssociationSpecLexBot{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BotAssociationSpecLexBot

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BotAssociationSpecLexBot{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BotAssociationSpecLexBot)(ptr) = obj
		} else {
			*(*BotAssociationSpecLexBot)(ptr) = BotAssociationSpecLexBot{}
		}
	default:
		iter.ReportError("decode BotAssociationSpecLexBot", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HoursOfOperationSpecConfigEndTimeCodec struct {
}

func (HoursOfOperationSpecConfigEndTimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HoursOfOperationSpecConfigEndTime)(ptr) == nil
}

func (HoursOfOperationSpecConfigEndTimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HoursOfOperationSpecConfigEndTime)(ptr)
	var objs []HoursOfOperationSpecConfigEndTime
	if obj != nil {
		objs = []HoursOfOperationSpecConfigEndTime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigEndTime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HoursOfOperationSpecConfigEndTimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HoursOfOperationSpecConfigEndTime)(ptr) = HoursOfOperationSpecConfigEndTime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HoursOfOperationSpecConfigEndTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigEndTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HoursOfOperationSpecConfigEndTime)(ptr) = objs[0]
			} else {
				*(*HoursOfOperationSpecConfigEndTime)(ptr) = HoursOfOperationSpecConfigEndTime{}
			}
		} else {
			*(*HoursOfOperationSpecConfigEndTime)(ptr) = HoursOfOperationSpecConfigEndTime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HoursOfOperationSpecConfigEndTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigEndTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HoursOfOperationSpecConfigEndTime)(ptr) = obj
		} else {
			*(*HoursOfOperationSpecConfigEndTime)(ptr) = HoursOfOperationSpecConfigEndTime{}
		}
	default:
		iter.ReportError("decode HoursOfOperationSpecConfigEndTime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HoursOfOperationSpecConfigStartTimeCodec struct {
}

func (HoursOfOperationSpecConfigStartTimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HoursOfOperationSpecConfigStartTime)(ptr) == nil
}

func (HoursOfOperationSpecConfigStartTimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HoursOfOperationSpecConfigStartTime)(ptr)
	var objs []HoursOfOperationSpecConfigStartTime
	if obj != nil {
		objs = []HoursOfOperationSpecConfigStartTime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigStartTime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HoursOfOperationSpecConfigStartTimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HoursOfOperationSpecConfigStartTime)(ptr) = HoursOfOperationSpecConfigStartTime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HoursOfOperationSpecConfigStartTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigStartTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HoursOfOperationSpecConfigStartTime)(ptr) = objs[0]
			} else {
				*(*HoursOfOperationSpecConfigStartTime)(ptr) = HoursOfOperationSpecConfigStartTime{}
			}
		} else {
			*(*HoursOfOperationSpecConfigStartTime)(ptr) = HoursOfOperationSpecConfigStartTime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HoursOfOperationSpecConfigStartTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HoursOfOperationSpecConfigStartTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HoursOfOperationSpecConfigStartTime)(ptr) = obj
		} else {
			*(*HoursOfOperationSpecConfigStartTime)(ptr) = HoursOfOperationSpecConfigStartTime{}
		}
	default:
		iter.ReportError("decode HoursOfOperationSpecConfigStartTime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type QueueSpecOutboundCallerConfigCodec struct {
}

func (QueueSpecOutboundCallerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*QueueSpecOutboundCallerConfig)(ptr) == nil
}

func (QueueSpecOutboundCallerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*QueueSpecOutboundCallerConfig)(ptr)
	var objs []QueueSpecOutboundCallerConfig
	if obj != nil {
		objs = []QueueSpecOutboundCallerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(QueueSpecOutboundCallerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (QueueSpecOutboundCallerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*QueueSpecOutboundCallerConfig)(ptr) = QueueSpecOutboundCallerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []QueueSpecOutboundCallerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(QueueSpecOutboundCallerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*QueueSpecOutboundCallerConfig)(ptr) = objs[0]
			} else {
				*(*QueueSpecOutboundCallerConfig)(ptr) = QueueSpecOutboundCallerConfig{}
			}
		} else {
			*(*QueueSpecOutboundCallerConfig)(ptr) = QueueSpecOutboundCallerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj QueueSpecOutboundCallerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(QueueSpecOutboundCallerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*QueueSpecOutboundCallerConfig)(ptr) = obj
		} else {
			*(*QueueSpecOutboundCallerConfig)(ptr) = QueueSpecOutboundCallerConfig{}
		}
	default:
		iter.ReportError("decode QueueSpecOutboundCallerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type QuickConnectSpecQuickConnectConfigCodec struct {
}

func (QuickConnectSpecQuickConnectConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*QuickConnectSpecQuickConnectConfig)(ptr) == nil
}

func (QuickConnectSpecQuickConnectConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*QuickConnectSpecQuickConnectConfig)(ptr)
	var objs []QuickConnectSpecQuickConnectConfig
	if obj != nil {
		objs = []QuickConnectSpecQuickConnectConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(QuickConnectSpecQuickConnectConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (QuickConnectSpecQuickConnectConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*QuickConnectSpecQuickConnectConfig)(ptr) = QuickConnectSpecQuickConnectConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []QuickConnectSpecQuickConnectConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(QuickConnectSpecQuickConnectConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*QuickConnectSpecQuickConnectConfig)(ptr) = objs[0]
			} else {
				*(*QuickConnectSpecQuickConnectConfig)(ptr) = QuickConnectSpecQuickConnectConfig{}
			}
		} else {
			*(*QuickConnectSpecQuickConnectConfig)(ptr) = QuickConnectSpecQuickConnectConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj QuickConnectSpecQuickConnectConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(QuickConnectSpecQuickConnectConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*QuickConnectSpecQuickConnectConfig)(ptr) = obj
		} else {
			*(*QuickConnectSpecQuickConnectConfig)(ptr) = QuickConnectSpecQuickConnectConfig{}
		}
	default:
		iter.ReportError("decode QuickConnectSpecQuickConnectConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UserHierarchyStructureSpecHierarchyStructureCodec struct {
}

func (UserHierarchyStructureSpecHierarchyStructureCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UserHierarchyStructureSpecHierarchyStructure)(ptr) == nil
}

func (UserHierarchyStructureSpecHierarchyStructureCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UserHierarchyStructureSpecHierarchyStructure)(ptr)
	var objs []UserHierarchyStructureSpecHierarchyStructure
	if obj != nil {
		objs = []UserHierarchyStructureSpecHierarchyStructure{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructure{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UserHierarchyStructureSpecHierarchyStructureCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UserHierarchyStructureSpecHierarchyStructure)(ptr) = UserHierarchyStructureSpecHierarchyStructure{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UserHierarchyStructureSpecHierarchyStructure

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructure{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UserHierarchyStructureSpecHierarchyStructure)(ptr) = objs[0]
			} else {
				*(*UserHierarchyStructureSpecHierarchyStructure)(ptr) = UserHierarchyStructureSpecHierarchyStructure{}
			}
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructure)(ptr) = UserHierarchyStructureSpecHierarchyStructure{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UserHierarchyStructureSpecHierarchyStructure

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructure{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UserHierarchyStructureSpecHierarchyStructure)(ptr) = obj
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructure)(ptr) = UserHierarchyStructureSpecHierarchyStructure{}
		}
	default:
		iter.ReportError("decode UserHierarchyStructureSpecHierarchyStructure", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UserHierarchyStructureSpecHierarchyStructureLevelFiveCodec struct {
}

func (UserHierarchyStructureSpecHierarchyStructureLevelFiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UserHierarchyStructureSpecHierarchyStructureLevelFive)(ptr) == nil
}

func (UserHierarchyStructureSpecHierarchyStructureLevelFiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UserHierarchyStructureSpecHierarchyStructureLevelFive)(ptr)
	var objs []UserHierarchyStructureSpecHierarchyStructureLevelFive
	if obj != nil {
		objs = []UserHierarchyStructureSpecHierarchyStructureLevelFive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UserHierarchyStructureSpecHierarchyStructureLevelFiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UserHierarchyStructureSpecHierarchyStructureLevelFive)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelFive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UserHierarchyStructureSpecHierarchyStructureLevelFive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelFive)(ptr) = objs[0]
			} else {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelFive)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelFive{}
			}
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelFive)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelFive{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UserHierarchyStructureSpecHierarchyStructureLevelFive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UserHierarchyStructureSpecHierarchyStructureLevelFive)(ptr) = obj
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelFive)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelFive{}
		}
	default:
		iter.ReportError("decode UserHierarchyStructureSpecHierarchyStructureLevelFive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UserHierarchyStructureSpecHierarchyStructureLevelFourCodec struct {
}

func (UserHierarchyStructureSpecHierarchyStructureLevelFourCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UserHierarchyStructureSpecHierarchyStructureLevelFour)(ptr) == nil
}

func (UserHierarchyStructureSpecHierarchyStructureLevelFourCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UserHierarchyStructureSpecHierarchyStructureLevelFour)(ptr)
	var objs []UserHierarchyStructureSpecHierarchyStructureLevelFour
	if obj != nil {
		objs = []UserHierarchyStructureSpecHierarchyStructureLevelFour{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFour{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UserHierarchyStructureSpecHierarchyStructureLevelFourCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UserHierarchyStructureSpecHierarchyStructureLevelFour)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelFour{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UserHierarchyStructureSpecHierarchyStructureLevelFour

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFour{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelFour)(ptr) = objs[0]
			} else {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelFour)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelFour{}
			}
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelFour)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelFour{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UserHierarchyStructureSpecHierarchyStructureLevelFour

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelFour{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UserHierarchyStructureSpecHierarchyStructureLevelFour)(ptr) = obj
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelFour)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelFour{}
		}
	default:
		iter.ReportError("decode UserHierarchyStructureSpecHierarchyStructureLevelFour", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UserHierarchyStructureSpecHierarchyStructureLevelOneCodec struct {
}

func (UserHierarchyStructureSpecHierarchyStructureLevelOneCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UserHierarchyStructureSpecHierarchyStructureLevelOne)(ptr) == nil
}

func (UserHierarchyStructureSpecHierarchyStructureLevelOneCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UserHierarchyStructureSpecHierarchyStructureLevelOne)(ptr)
	var objs []UserHierarchyStructureSpecHierarchyStructureLevelOne
	if obj != nil {
		objs = []UserHierarchyStructureSpecHierarchyStructureLevelOne{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelOne{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UserHierarchyStructureSpecHierarchyStructureLevelOneCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UserHierarchyStructureSpecHierarchyStructureLevelOne)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelOne{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UserHierarchyStructureSpecHierarchyStructureLevelOne

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelOne{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelOne)(ptr) = objs[0]
			} else {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelOne)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelOne{}
			}
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelOne)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelOne{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UserHierarchyStructureSpecHierarchyStructureLevelOne

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelOne{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UserHierarchyStructureSpecHierarchyStructureLevelOne)(ptr) = obj
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelOne)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelOne{}
		}
	default:
		iter.ReportError("decode UserHierarchyStructureSpecHierarchyStructureLevelOne", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UserHierarchyStructureSpecHierarchyStructureLevelThreeCodec struct {
}

func (UserHierarchyStructureSpecHierarchyStructureLevelThreeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UserHierarchyStructureSpecHierarchyStructureLevelThree)(ptr) == nil
}

func (UserHierarchyStructureSpecHierarchyStructureLevelThreeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UserHierarchyStructureSpecHierarchyStructureLevelThree)(ptr)
	var objs []UserHierarchyStructureSpecHierarchyStructureLevelThree
	if obj != nil {
		objs = []UserHierarchyStructureSpecHierarchyStructureLevelThree{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelThree{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UserHierarchyStructureSpecHierarchyStructureLevelThreeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UserHierarchyStructureSpecHierarchyStructureLevelThree)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelThree{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UserHierarchyStructureSpecHierarchyStructureLevelThree

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelThree{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelThree)(ptr) = objs[0]
			} else {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelThree)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelThree{}
			}
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelThree)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelThree{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UserHierarchyStructureSpecHierarchyStructureLevelThree

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelThree{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UserHierarchyStructureSpecHierarchyStructureLevelThree)(ptr) = obj
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelThree)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelThree{}
		}
	default:
		iter.ReportError("decode UserHierarchyStructureSpecHierarchyStructureLevelThree", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UserHierarchyStructureSpecHierarchyStructureLevelTwoCodec struct {
}

func (UserHierarchyStructureSpecHierarchyStructureLevelTwoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UserHierarchyStructureSpecHierarchyStructureLevelTwo)(ptr) == nil
}

func (UserHierarchyStructureSpecHierarchyStructureLevelTwoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UserHierarchyStructureSpecHierarchyStructureLevelTwo)(ptr)
	var objs []UserHierarchyStructureSpecHierarchyStructureLevelTwo
	if obj != nil {
		objs = []UserHierarchyStructureSpecHierarchyStructureLevelTwo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelTwo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UserHierarchyStructureSpecHierarchyStructureLevelTwoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UserHierarchyStructureSpecHierarchyStructureLevelTwo)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelTwo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UserHierarchyStructureSpecHierarchyStructureLevelTwo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelTwo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelTwo)(ptr) = objs[0]
			} else {
				*(*UserHierarchyStructureSpecHierarchyStructureLevelTwo)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelTwo{}
			}
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelTwo)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelTwo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UserHierarchyStructureSpecHierarchyStructureLevelTwo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UserHierarchyStructureSpecHierarchyStructureLevelTwo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UserHierarchyStructureSpecHierarchyStructureLevelTwo)(ptr) = obj
		} else {
			*(*UserHierarchyStructureSpecHierarchyStructureLevelTwo)(ptr) = UserHierarchyStructureSpecHierarchyStructureLevelTwo{}
		}
	default:
		iter.ReportError("decode UserHierarchyStructureSpecHierarchyStructureLevelTwo", "unexpected JSON type")
	}
}
