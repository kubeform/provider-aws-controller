/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecPublicAccessBlockConfiguration{}).Type1()):                                                AccessPointSpecPublicAccessBlockConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecVpcConfiguration{}).Type1()):                                                              AccessPointSpecVpcConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfiguration{}).Type1()):                                                            BucketSpecObjectLockConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicy{}).Type1()):                                                             BucketACLSpecAccessControlPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyGrantGrantee{}).Type1()):                                                 BucketACLSpecAccessControlPolicyGrantGranteeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyOwner{}).Type1()):                                                        BucketACLSpecAccessControlPolicyOwnerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecFilter{}).Type1()):                                                       BucketAnalyticsConfigurationSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysis{}).Type1()):                                         BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}).Type1()):                               BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}).Type1()):                    BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}).Type1()): BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketIntelligentTieringConfigurationSpecFilter{}).Type1()):                                              BucketIntelligentTieringConfigurationSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestination{}).Type1()):                                                               BucketInventorySpecDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucket{}).Type1()):                                                         BucketInventorySpecDestinationBucketCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryption{}).Type1()):                                               BucketInventorySpecDestinationBucketEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseKms{}).Type1()):                                         BucketInventorySpecDestinationBucketEncryptionSseKmsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseS3{}).Type1()):                                          BucketInventorySpecDestinationBucketEncryptionSseS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecFilter{}).Type1()):                                                                    BucketInventorySpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecSchedule{}).Type1()):                                                                  BucketInventorySpecScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{}).Type1()):                           BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUploadCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleExpiration{}).Type1()):                                               BucketLifecycleConfigurationSpecRuleExpirationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilter{}).Type1()):                                                   BucketLifecycleConfigurationSpecRuleFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterAnd{}).Type1()):                                                BucketLifecycleConfigurationSpecRuleFilterAndCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterTag{}).Type1()):                                                BucketLifecycleConfigurationSpecRuleFilterTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{}).Type1()):                              BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpirationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLoggingSpecTargetGrantGrantee{}).Type1()):                                                          BucketLoggingSpecTargetGrantGranteeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketMetricSpecFilter{}).Type1()):                                                                       BucketMetricSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRule{}).Type1()):                                                        BucketObjectLockConfigurationSpecRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRuleDefaultRetention{}).Type1()):                                        BucketObjectLockConfigurationSpecRuleDefaultRetentionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketOwnershipControlsSpecRule{}).Type1()):                                                              BucketOwnershipControlsSpecRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{}).Type1()):                                BucketReplicationConfigurationSpecRuleDeleteMarkerReplicationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestination{}).Type1()):                                            BucketReplicationConfigurationSpecRuleDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{}).Type1()):                    BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{}).Type1()):                     BucketReplicationConfigurationSpecRuleDestinationEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetrics{}).Type1()):                                     BucketReplicationConfigurationSpecRuleDestinationMetricsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{}).Type1()):                       BucketReplicationConfigurationSpecRuleDestinationMetricsEventThresholdCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTime{}).Type1()):                             BucketReplicationConfigurationSpecRuleDestinationReplicationTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{}).Type1()):                         BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleExistingObjectReplication{}).Type1()):                              BucketReplicationConfigurationSpecRuleExistingObjectReplicationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilter{}).Type1()):                                                 BucketReplicationConfigurationSpecRuleFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterAnd{}).Type1()):                                              BucketReplicationConfigurationSpecRuleFilterAndCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterTag{}).Type1()):                                              BucketReplicationConfigurationSpecRuleFilterTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{}).Type1()):                                BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{}).Type1()):            BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModificationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{}).Type1()):          BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjectsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{}).Type1()):            BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefaultCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketVersioningSpecVersioningConfiguration{}).Type1()):                                                  BucketVersioningSpecVersioningConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecErrorDocument{}).Type1()):                                                  BucketWebsiteConfigurationSpecErrorDocumentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecIndexDocument{}).Type1()):                                                  BucketWebsiteConfigurationSpecIndexDocumentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRedirectAllRequestsTo{}).Type1()):                                          BucketWebsiteConfigurationSpecRedirectAllRequestsToCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleCondition{}).Type1()):                                           BucketWebsiteConfigurationSpecRoutingRuleConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleRedirect{}).Type1()):                                            BucketWebsiteConfigurationSpecRoutingRuleRedirectCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecPublicAccessBlockConfiguration{}).Type1()):                                                AccessPointSpecPublicAccessBlockConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecVpcConfiguration{}).Type1()):                                                              AccessPointSpecVpcConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfiguration{}).Type1()):                                                            BucketSpecObjectLockConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicy{}).Type1()):                                                             BucketACLSpecAccessControlPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyGrantGrantee{}).Type1()):                                                 BucketACLSpecAccessControlPolicyGrantGranteeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyOwner{}).Type1()):                                                        BucketACLSpecAccessControlPolicyOwnerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecFilter{}).Type1()):                                                       BucketAnalyticsConfigurationSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysis{}).Type1()):                                         BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}).Type1()):                               BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}).Type1()):                    BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}).Type1()): BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketIntelligentTieringConfigurationSpecFilter{}).Type1()):                                              BucketIntelligentTieringConfigurationSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestination{}).Type1()):                                                               BucketInventorySpecDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucket{}).Type1()):                                                         BucketInventorySpecDestinationBucketCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryption{}).Type1()):                                               BucketInventorySpecDestinationBucketEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseKms{}).Type1()):                                         BucketInventorySpecDestinationBucketEncryptionSseKmsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseS3{}).Type1()):                                          BucketInventorySpecDestinationBucketEncryptionSseS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecFilter{}).Type1()):                                                                    BucketInventorySpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecSchedule{}).Type1()):                                                                  BucketInventorySpecScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{}).Type1()):                           BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUploadCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleExpiration{}).Type1()):                                               BucketLifecycleConfigurationSpecRuleExpirationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilter{}).Type1()):                                                   BucketLifecycleConfigurationSpecRuleFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterAnd{}).Type1()):                                                BucketLifecycleConfigurationSpecRuleFilterAndCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterTag{}).Type1()):                                                BucketLifecycleConfigurationSpecRuleFilterTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{}).Type1()):                              BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpirationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketLoggingSpecTargetGrantGrantee{}).Type1()):                                                          BucketLoggingSpecTargetGrantGranteeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketMetricSpecFilter{}).Type1()):                                                                       BucketMetricSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRule{}).Type1()):                                                        BucketObjectLockConfigurationSpecRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRuleDefaultRetention{}).Type1()):                                        BucketObjectLockConfigurationSpecRuleDefaultRetentionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketOwnershipControlsSpecRule{}).Type1()):                                                              BucketOwnershipControlsSpecRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{}).Type1()):                                BucketReplicationConfigurationSpecRuleDeleteMarkerReplicationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestination{}).Type1()):                                            BucketReplicationConfigurationSpecRuleDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{}).Type1()):                    BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{}).Type1()):                     BucketReplicationConfigurationSpecRuleDestinationEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetrics{}).Type1()):                                     BucketReplicationConfigurationSpecRuleDestinationMetricsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{}).Type1()):                       BucketReplicationConfigurationSpecRuleDestinationMetricsEventThresholdCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTime{}).Type1()):                             BucketReplicationConfigurationSpecRuleDestinationReplicationTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{}).Type1()):                         BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleExistingObjectReplication{}).Type1()):                              BucketReplicationConfigurationSpecRuleExistingObjectReplicationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilter{}).Type1()):                                                 BucketReplicationConfigurationSpecRuleFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterAnd{}).Type1()):                                              BucketReplicationConfigurationSpecRuleFilterAndCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterTag{}).Type1()):                                              BucketReplicationConfigurationSpecRuleFilterTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{}).Type1()):                                BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{}).Type1()):            BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModificationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{}).Type1()):          BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjectsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{}).Type1()):            BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefaultCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketVersioningSpecVersioningConfiguration{}).Type1()):                                                  BucketVersioningSpecVersioningConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecErrorDocument{}).Type1()):                                                  BucketWebsiteConfigurationSpecErrorDocumentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecIndexDocument{}).Type1()):                                                  BucketWebsiteConfigurationSpecIndexDocumentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRedirectAllRequestsTo{}).Type1()):                                          BucketWebsiteConfigurationSpecRedirectAllRequestsToCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleCondition{}).Type1()):                                           BucketWebsiteConfigurationSpecRoutingRuleConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleRedirect{}).Type1()):                                            BucketWebsiteConfigurationSpecRoutingRuleRedirectCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AccessPointSpecPublicAccessBlockConfigurationCodec struct {
}

func (AccessPointSpecPublicAccessBlockConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccessPointSpecPublicAccessBlockConfiguration)(ptr) == nil
}

func (AccessPointSpecPublicAccessBlockConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccessPointSpecPublicAccessBlockConfiguration)(ptr)
	var objs []AccessPointSpecPublicAccessBlockConfiguration
	if obj != nil {
		objs = []AccessPointSpecPublicAccessBlockConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecPublicAccessBlockConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccessPointSpecPublicAccessBlockConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = AccessPointSpecPublicAccessBlockConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccessPointSpecPublicAccessBlockConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecPublicAccessBlockConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = objs[0]
			} else {
				*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = AccessPointSpecPublicAccessBlockConfiguration{}
			}
		} else {
			*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = AccessPointSpecPublicAccessBlockConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AccessPointSpecPublicAccessBlockConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecPublicAccessBlockConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = obj
		} else {
			*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = AccessPointSpecPublicAccessBlockConfiguration{}
		}
	default:
		iter.ReportError("decode AccessPointSpecPublicAccessBlockConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccessPointSpecVpcConfigurationCodec struct {
}

func (AccessPointSpecVpcConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccessPointSpecVpcConfiguration)(ptr) == nil
}

func (AccessPointSpecVpcConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccessPointSpecVpcConfiguration)(ptr)
	var objs []AccessPointSpecVpcConfiguration
	if obj != nil {
		objs = []AccessPointSpecVpcConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecVpcConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccessPointSpecVpcConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccessPointSpecVpcConfiguration)(ptr) = AccessPointSpecVpcConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccessPointSpecVpcConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecVpcConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccessPointSpecVpcConfiguration)(ptr) = objs[0]
			} else {
				*(*AccessPointSpecVpcConfiguration)(ptr) = AccessPointSpecVpcConfiguration{}
			}
		} else {
			*(*AccessPointSpecVpcConfiguration)(ptr) = AccessPointSpecVpcConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AccessPointSpecVpcConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecVpcConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AccessPointSpecVpcConfiguration)(ptr) = obj
		} else {
			*(*AccessPointSpecVpcConfiguration)(ptr) = AccessPointSpecVpcConfiguration{}
		}
	default:
		iter.ReportError("decode AccessPointSpecVpcConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecObjectLockConfigurationCodec struct {
}

func (BucketSpecObjectLockConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecObjectLockConfiguration)(ptr) == nil
}

func (BucketSpecObjectLockConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecObjectLockConfiguration)(ptr)
	var objs []BucketSpecObjectLockConfiguration
	if obj != nil {
		objs = []BucketSpecObjectLockConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecObjectLockConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecObjectLockConfiguration)(ptr) = BucketSpecObjectLockConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecObjectLockConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecObjectLockConfiguration)(ptr) = objs[0]
			} else {
				*(*BucketSpecObjectLockConfiguration)(ptr) = BucketSpecObjectLockConfiguration{}
			}
		} else {
			*(*BucketSpecObjectLockConfiguration)(ptr) = BucketSpecObjectLockConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketSpecObjectLockConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketSpecObjectLockConfiguration)(ptr) = obj
		} else {
			*(*BucketSpecObjectLockConfiguration)(ptr) = BucketSpecObjectLockConfiguration{}
		}
	default:
		iter.ReportError("decode BucketSpecObjectLockConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketACLSpecAccessControlPolicyCodec struct {
}

func (BucketACLSpecAccessControlPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketACLSpecAccessControlPolicy)(ptr) == nil
}

func (BucketACLSpecAccessControlPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketACLSpecAccessControlPolicy)(ptr)
	var objs []BucketACLSpecAccessControlPolicy
	if obj != nil {
		objs = []BucketACLSpecAccessControlPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketACLSpecAccessControlPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketACLSpecAccessControlPolicy)(ptr) = BucketACLSpecAccessControlPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketACLSpecAccessControlPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketACLSpecAccessControlPolicy)(ptr) = objs[0]
			} else {
				*(*BucketACLSpecAccessControlPolicy)(ptr) = BucketACLSpecAccessControlPolicy{}
			}
		} else {
			*(*BucketACLSpecAccessControlPolicy)(ptr) = BucketACLSpecAccessControlPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketACLSpecAccessControlPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketACLSpecAccessControlPolicy)(ptr) = obj
		} else {
			*(*BucketACLSpecAccessControlPolicy)(ptr) = BucketACLSpecAccessControlPolicy{}
		}
	default:
		iter.ReportError("decode BucketACLSpecAccessControlPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketACLSpecAccessControlPolicyGrantGranteeCodec struct {
}

func (BucketACLSpecAccessControlPolicyGrantGranteeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketACLSpecAccessControlPolicyGrantGrantee)(ptr) == nil
}

func (BucketACLSpecAccessControlPolicyGrantGranteeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketACLSpecAccessControlPolicyGrantGrantee)(ptr)
	var objs []BucketACLSpecAccessControlPolicyGrantGrantee
	if obj != nil {
		objs = []BucketACLSpecAccessControlPolicyGrantGrantee{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyGrantGrantee{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketACLSpecAccessControlPolicyGrantGranteeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketACLSpecAccessControlPolicyGrantGrantee)(ptr) = BucketACLSpecAccessControlPolicyGrantGrantee{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketACLSpecAccessControlPolicyGrantGrantee

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyGrantGrantee{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketACLSpecAccessControlPolicyGrantGrantee)(ptr) = objs[0]
			} else {
				*(*BucketACLSpecAccessControlPolicyGrantGrantee)(ptr) = BucketACLSpecAccessControlPolicyGrantGrantee{}
			}
		} else {
			*(*BucketACLSpecAccessControlPolicyGrantGrantee)(ptr) = BucketACLSpecAccessControlPolicyGrantGrantee{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketACLSpecAccessControlPolicyGrantGrantee

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyGrantGrantee{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketACLSpecAccessControlPolicyGrantGrantee)(ptr) = obj
		} else {
			*(*BucketACLSpecAccessControlPolicyGrantGrantee)(ptr) = BucketACLSpecAccessControlPolicyGrantGrantee{}
		}
	default:
		iter.ReportError("decode BucketACLSpecAccessControlPolicyGrantGrantee", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketACLSpecAccessControlPolicyOwnerCodec struct {
}

func (BucketACLSpecAccessControlPolicyOwnerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketACLSpecAccessControlPolicyOwner)(ptr) == nil
}

func (BucketACLSpecAccessControlPolicyOwnerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketACLSpecAccessControlPolicyOwner)(ptr)
	var objs []BucketACLSpecAccessControlPolicyOwner
	if obj != nil {
		objs = []BucketACLSpecAccessControlPolicyOwner{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyOwner{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketACLSpecAccessControlPolicyOwnerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketACLSpecAccessControlPolicyOwner)(ptr) = BucketACLSpecAccessControlPolicyOwner{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketACLSpecAccessControlPolicyOwner

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyOwner{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketACLSpecAccessControlPolicyOwner)(ptr) = objs[0]
			} else {
				*(*BucketACLSpecAccessControlPolicyOwner)(ptr) = BucketACLSpecAccessControlPolicyOwner{}
			}
		} else {
			*(*BucketACLSpecAccessControlPolicyOwner)(ptr) = BucketACLSpecAccessControlPolicyOwner{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketACLSpecAccessControlPolicyOwner

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketACLSpecAccessControlPolicyOwner{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketACLSpecAccessControlPolicyOwner)(ptr) = obj
		} else {
			*(*BucketACLSpecAccessControlPolicyOwner)(ptr) = BucketACLSpecAccessControlPolicyOwner{}
		}
	default:
		iter.ReportError("decode BucketACLSpecAccessControlPolicyOwner", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecFilterCodec struct {
}

func (BucketAnalyticsConfigurationSpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecFilter)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecFilter)(ptr)
	var objs []BucketAnalyticsConfigurationSpecFilter
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = BucketAnalyticsConfigurationSpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = BucketAnalyticsConfigurationSpecFilter{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = BucketAnalyticsConfigurationSpecFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketAnalyticsConfigurationSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = obj
		} else {
			*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = BucketAnalyticsConfigurationSpecFilter{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec struct {
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr)
	var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysis
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecStorageClassAnalysis{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysis{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysis{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysis

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysis{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysis{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysis{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketAnalyticsConfigurationSpecStorageClassAnalysis

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysis{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = obj
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysis{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecStorageClassAnalysis", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec struct {
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr)
	var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = obj
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec struct {
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr)
	var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = obj
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec struct {
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr)
	var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = obj
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketIntelligentTieringConfigurationSpecFilterCodec struct {
}

func (BucketIntelligentTieringConfigurationSpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketIntelligentTieringConfigurationSpecFilter)(ptr) == nil
}

func (BucketIntelligentTieringConfigurationSpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketIntelligentTieringConfigurationSpecFilter)(ptr)
	var objs []BucketIntelligentTieringConfigurationSpecFilter
	if obj != nil {
		objs = []BucketIntelligentTieringConfigurationSpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketIntelligentTieringConfigurationSpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketIntelligentTieringConfigurationSpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketIntelligentTieringConfigurationSpecFilter)(ptr) = BucketIntelligentTieringConfigurationSpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketIntelligentTieringConfigurationSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketIntelligentTieringConfigurationSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketIntelligentTieringConfigurationSpecFilter)(ptr) = objs[0]
			} else {
				*(*BucketIntelligentTieringConfigurationSpecFilter)(ptr) = BucketIntelligentTieringConfigurationSpecFilter{}
			}
		} else {
			*(*BucketIntelligentTieringConfigurationSpecFilter)(ptr) = BucketIntelligentTieringConfigurationSpecFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketIntelligentTieringConfigurationSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketIntelligentTieringConfigurationSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketIntelligentTieringConfigurationSpecFilter)(ptr) = obj
		} else {
			*(*BucketIntelligentTieringConfigurationSpecFilter)(ptr) = BucketIntelligentTieringConfigurationSpecFilter{}
		}
	default:
		iter.ReportError("decode BucketIntelligentTieringConfigurationSpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationCodec struct {
}

func (BucketInventorySpecDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestination)(ptr) == nil
}

func (BucketInventorySpecDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestination)(ptr)
	var objs []BucketInventorySpecDestination
	if obj != nil {
		objs = []BucketInventorySpecDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestination)(ptr) = BucketInventorySpecDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestination)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestination)(ptr) = BucketInventorySpecDestination{}
			}
		} else {
			*(*BucketInventorySpecDestination)(ptr) = BucketInventorySpecDestination{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketInventorySpecDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketInventorySpecDestination)(ptr) = obj
		} else {
			*(*BucketInventorySpecDestination)(ptr) = BucketInventorySpecDestination{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationBucketCodec struct {
}

func (BucketInventorySpecDestinationBucketCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestinationBucket)(ptr) == nil
}

func (BucketInventorySpecDestinationBucketCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestinationBucket)(ptr)
	var objs []BucketInventorySpecDestinationBucket
	if obj != nil {
		objs = []BucketInventorySpecDestinationBucket{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucket{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationBucketCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestinationBucket)(ptr) = BucketInventorySpecDestinationBucket{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestinationBucket

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucket{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestinationBucket)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestinationBucket)(ptr) = BucketInventorySpecDestinationBucket{}
			}
		} else {
			*(*BucketInventorySpecDestinationBucket)(ptr) = BucketInventorySpecDestinationBucket{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketInventorySpecDestinationBucket

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucket{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketInventorySpecDestinationBucket)(ptr) = obj
		} else {
			*(*BucketInventorySpecDestinationBucket)(ptr) = BucketInventorySpecDestinationBucket{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestinationBucket", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationBucketEncryptionCodec struct {
}

func (BucketInventorySpecDestinationBucketEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestinationBucketEncryption)(ptr) == nil
}

func (BucketInventorySpecDestinationBucketEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestinationBucketEncryption)(ptr)
	var objs []BucketInventorySpecDestinationBucketEncryption
	if obj != nil {
		objs = []BucketInventorySpecDestinationBucketEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationBucketEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = BucketInventorySpecDestinationBucketEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestinationBucketEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = BucketInventorySpecDestinationBucketEncryption{}
			}
		} else {
			*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = BucketInventorySpecDestinationBucketEncryption{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketInventorySpecDestinationBucketEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = obj
		} else {
			*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = BucketInventorySpecDestinationBucketEncryption{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestinationBucketEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationBucketEncryptionSseKmsCodec struct {
}

func (BucketInventorySpecDestinationBucketEncryptionSseKmsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) == nil
}

func (BucketInventorySpecDestinationBucketEncryptionSseKmsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr)
	var objs []BucketInventorySpecDestinationBucketEncryptionSseKms
	if obj != nil {
		objs = []BucketInventorySpecDestinationBucketEncryptionSseKms{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseKms{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationBucketEncryptionSseKmsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseKms{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestinationBucketEncryptionSseKms

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseKms{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseKms{}
			}
		} else {
			*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseKms{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketInventorySpecDestinationBucketEncryptionSseKms

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseKms{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = obj
		} else {
			*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseKms{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestinationBucketEncryptionSseKms", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationBucketEncryptionSseS3Codec struct {
}

func (BucketInventorySpecDestinationBucketEncryptionSseS3Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) == nil
}

func (BucketInventorySpecDestinationBucketEncryptionSseS3Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr)
	var objs []BucketInventorySpecDestinationBucketEncryptionSseS3
	if obj != nil {
		objs = []BucketInventorySpecDestinationBucketEncryptionSseS3{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseS3{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationBucketEncryptionSseS3Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseS3{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestinationBucketEncryptionSseS3

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseS3{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseS3{}
			}
		} else {
			*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseS3{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketInventorySpecDestinationBucketEncryptionSseS3

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseS3{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = obj
		} else {
			*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseS3{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestinationBucketEncryptionSseS3", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecFilterCodec struct {
}

func (BucketInventorySpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecFilter)(ptr) == nil
}

func (BucketInventorySpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecFilter)(ptr)
	var objs []BucketInventorySpecFilter
	if obj != nil {
		objs = []BucketInventorySpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecFilter)(ptr) = BucketInventorySpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecFilter)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecFilter)(ptr) = BucketInventorySpecFilter{}
			}
		} else {
			*(*BucketInventorySpecFilter)(ptr) = BucketInventorySpecFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketInventorySpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketInventorySpecFilter)(ptr) = obj
		} else {
			*(*BucketInventorySpecFilter)(ptr) = BucketInventorySpecFilter{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecScheduleCodec struct {
}

func (BucketInventorySpecScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecSchedule)(ptr) == nil
}

func (BucketInventorySpecScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecSchedule)(ptr)
	var objs []BucketInventorySpecSchedule
	if obj != nil {
		objs = []BucketInventorySpecSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecSchedule)(ptr) = BucketInventorySpecSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecSchedule)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecSchedule)(ptr) = BucketInventorySpecSchedule{}
			}
		} else {
			*(*BucketInventorySpecSchedule)(ptr) = BucketInventorySpecSchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketInventorySpecSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketInventorySpecSchedule)(ptr) = obj
		} else {
			*(*BucketInventorySpecSchedule)(ptr) = BucketInventorySpecSchedule{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUploadCodec struct {
}

func (BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUploadCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload)(ptr) == nil
}

func (BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUploadCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload)(ptr)
	var objs []BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload
	if obj != nil {
		objs = []BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUploadCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload)(ptr) = BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload)(ptr) = objs[0]
			} else {
				*(*BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload)(ptr) = BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{}
			}
		} else {
			*(*BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload)(ptr) = BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload)(ptr) = obj
		} else {
			*(*BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload)(ptr) = BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload{}
		}
	default:
		iter.ReportError("decode BucketLifecycleConfigurationSpecRuleAbortIncompleteMultipartUpload", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketLifecycleConfigurationSpecRuleExpirationCodec struct {
}

func (BucketLifecycleConfigurationSpecRuleExpirationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketLifecycleConfigurationSpecRuleExpiration)(ptr) == nil
}

func (BucketLifecycleConfigurationSpecRuleExpirationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketLifecycleConfigurationSpecRuleExpiration)(ptr)
	var objs []BucketLifecycleConfigurationSpecRuleExpiration
	if obj != nil {
		objs = []BucketLifecycleConfigurationSpecRuleExpiration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleExpiration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketLifecycleConfigurationSpecRuleExpirationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketLifecycleConfigurationSpecRuleExpiration)(ptr) = BucketLifecycleConfigurationSpecRuleExpiration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketLifecycleConfigurationSpecRuleExpiration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleExpiration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketLifecycleConfigurationSpecRuleExpiration)(ptr) = objs[0]
			} else {
				*(*BucketLifecycleConfigurationSpecRuleExpiration)(ptr) = BucketLifecycleConfigurationSpecRuleExpiration{}
			}
		} else {
			*(*BucketLifecycleConfigurationSpecRuleExpiration)(ptr) = BucketLifecycleConfigurationSpecRuleExpiration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketLifecycleConfigurationSpecRuleExpiration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleExpiration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketLifecycleConfigurationSpecRuleExpiration)(ptr) = obj
		} else {
			*(*BucketLifecycleConfigurationSpecRuleExpiration)(ptr) = BucketLifecycleConfigurationSpecRuleExpiration{}
		}
	default:
		iter.ReportError("decode BucketLifecycleConfigurationSpecRuleExpiration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketLifecycleConfigurationSpecRuleFilterCodec struct {
}

func (BucketLifecycleConfigurationSpecRuleFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketLifecycleConfigurationSpecRuleFilter)(ptr) == nil
}

func (BucketLifecycleConfigurationSpecRuleFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketLifecycleConfigurationSpecRuleFilter)(ptr)
	var objs []BucketLifecycleConfigurationSpecRuleFilter
	if obj != nil {
		objs = []BucketLifecycleConfigurationSpecRuleFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketLifecycleConfigurationSpecRuleFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketLifecycleConfigurationSpecRuleFilter)(ptr) = BucketLifecycleConfigurationSpecRuleFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketLifecycleConfigurationSpecRuleFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketLifecycleConfigurationSpecRuleFilter)(ptr) = objs[0]
			} else {
				*(*BucketLifecycleConfigurationSpecRuleFilter)(ptr) = BucketLifecycleConfigurationSpecRuleFilter{}
			}
		} else {
			*(*BucketLifecycleConfigurationSpecRuleFilter)(ptr) = BucketLifecycleConfigurationSpecRuleFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketLifecycleConfigurationSpecRuleFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketLifecycleConfigurationSpecRuleFilter)(ptr) = obj
		} else {
			*(*BucketLifecycleConfigurationSpecRuleFilter)(ptr) = BucketLifecycleConfigurationSpecRuleFilter{}
		}
	default:
		iter.ReportError("decode BucketLifecycleConfigurationSpecRuleFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketLifecycleConfigurationSpecRuleFilterAndCodec struct {
}

func (BucketLifecycleConfigurationSpecRuleFilterAndCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketLifecycleConfigurationSpecRuleFilterAnd)(ptr) == nil
}

func (BucketLifecycleConfigurationSpecRuleFilterAndCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketLifecycleConfigurationSpecRuleFilterAnd)(ptr)
	var objs []BucketLifecycleConfigurationSpecRuleFilterAnd
	if obj != nil {
		objs = []BucketLifecycleConfigurationSpecRuleFilterAnd{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterAnd{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketLifecycleConfigurationSpecRuleFilterAndCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketLifecycleConfigurationSpecRuleFilterAnd)(ptr) = BucketLifecycleConfigurationSpecRuleFilterAnd{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketLifecycleConfigurationSpecRuleFilterAnd

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterAnd{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketLifecycleConfigurationSpecRuleFilterAnd)(ptr) = objs[0]
			} else {
				*(*BucketLifecycleConfigurationSpecRuleFilterAnd)(ptr) = BucketLifecycleConfigurationSpecRuleFilterAnd{}
			}
		} else {
			*(*BucketLifecycleConfigurationSpecRuleFilterAnd)(ptr) = BucketLifecycleConfigurationSpecRuleFilterAnd{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketLifecycleConfigurationSpecRuleFilterAnd

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterAnd{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketLifecycleConfigurationSpecRuleFilterAnd)(ptr) = obj
		} else {
			*(*BucketLifecycleConfigurationSpecRuleFilterAnd)(ptr) = BucketLifecycleConfigurationSpecRuleFilterAnd{}
		}
	default:
		iter.ReportError("decode BucketLifecycleConfigurationSpecRuleFilterAnd", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketLifecycleConfigurationSpecRuleFilterTagCodec struct {
}

func (BucketLifecycleConfigurationSpecRuleFilterTagCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketLifecycleConfigurationSpecRuleFilterTag)(ptr) == nil
}

func (BucketLifecycleConfigurationSpecRuleFilterTagCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketLifecycleConfigurationSpecRuleFilterTag)(ptr)
	var objs []BucketLifecycleConfigurationSpecRuleFilterTag
	if obj != nil {
		objs = []BucketLifecycleConfigurationSpecRuleFilterTag{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterTag{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketLifecycleConfigurationSpecRuleFilterTagCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketLifecycleConfigurationSpecRuleFilterTag)(ptr) = BucketLifecycleConfigurationSpecRuleFilterTag{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketLifecycleConfigurationSpecRuleFilterTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketLifecycleConfigurationSpecRuleFilterTag)(ptr) = objs[0]
			} else {
				*(*BucketLifecycleConfigurationSpecRuleFilterTag)(ptr) = BucketLifecycleConfigurationSpecRuleFilterTag{}
			}
		} else {
			*(*BucketLifecycleConfigurationSpecRuleFilterTag)(ptr) = BucketLifecycleConfigurationSpecRuleFilterTag{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketLifecycleConfigurationSpecRuleFilterTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleFilterTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketLifecycleConfigurationSpecRuleFilterTag)(ptr) = obj
		} else {
			*(*BucketLifecycleConfigurationSpecRuleFilterTag)(ptr) = BucketLifecycleConfigurationSpecRuleFilterTag{}
		}
	default:
		iter.ReportError("decode BucketLifecycleConfigurationSpecRuleFilterTag", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpirationCodec struct {
}

func (BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpirationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration)(ptr) == nil
}

func (BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpirationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration)(ptr)
	var objs []BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration
	if obj != nil {
		objs = []BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpirationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration)(ptr) = BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration)(ptr) = objs[0]
			} else {
				*(*BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration)(ptr) = BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{}
			}
		} else {
			*(*BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration)(ptr) = BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration)(ptr) = obj
		} else {
			*(*BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration)(ptr) = BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration{}
		}
	default:
		iter.ReportError("decode BucketLifecycleConfigurationSpecRuleNoncurrentVersionExpiration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketLoggingSpecTargetGrantGranteeCodec struct {
}

func (BucketLoggingSpecTargetGrantGranteeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketLoggingSpecTargetGrantGrantee)(ptr) == nil
}

func (BucketLoggingSpecTargetGrantGranteeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketLoggingSpecTargetGrantGrantee)(ptr)
	var objs []BucketLoggingSpecTargetGrantGrantee
	if obj != nil {
		objs = []BucketLoggingSpecTargetGrantGrantee{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLoggingSpecTargetGrantGrantee{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketLoggingSpecTargetGrantGranteeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketLoggingSpecTargetGrantGrantee)(ptr) = BucketLoggingSpecTargetGrantGrantee{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketLoggingSpecTargetGrantGrantee

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLoggingSpecTargetGrantGrantee{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketLoggingSpecTargetGrantGrantee)(ptr) = objs[0]
			} else {
				*(*BucketLoggingSpecTargetGrantGrantee)(ptr) = BucketLoggingSpecTargetGrantGrantee{}
			}
		} else {
			*(*BucketLoggingSpecTargetGrantGrantee)(ptr) = BucketLoggingSpecTargetGrantGrantee{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketLoggingSpecTargetGrantGrantee

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketLoggingSpecTargetGrantGrantee{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketLoggingSpecTargetGrantGrantee)(ptr) = obj
		} else {
			*(*BucketLoggingSpecTargetGrantGrantee)(ptr) = BucketLoggingSpecTargetGrantGrantee{}
		}
	default:
		iter.ReportError("decode BucketLoggingSpecTargetGrantGrantee", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketMetricSpecFilterCodec struct {
}

func (BucketMetricSpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketMetricSpecFilter)(ptr) == nil
}

func (BucketMetricSpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketMetricSpecFilter)(ptr)
	var objs []BucketMetricSpecFilter
	if obj != nil {
		objs = []BucketMetricSpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketMetricSpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketMetricSpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketMetricSpecFilter)(ptr) = BucketMetricSpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketMetricSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketMetricSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketMetricSpecFilter)(ptr) = objs[0]
			} else {
				*(*BucketMetricSpecFilter)(ptr) = BucketMetricSpecFilter{}
			}
		} else {
			*(*BucketMetricSpecFilter)(ptr) = BucketMetricSpecFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketMetricSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketMetricSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketMetricSpecFilter)(ptr) = obj
		} else {
			*(*BucketMetricSpecFilter)(ptr) = BucketMetricSpecFilter{}
		}
	default:
		iter.ReportError("decode BucketMetricSpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketObjectLockConfigurationSpecRuleCodec struct {
}

func (BucketObjectLockConfigurationSpecRuleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketObjectLockConfigurationSpecRule)(ptr) == nil
}

func (BucketObjectLockConfigurationSpecRuleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketObjectLockConfigurationSpecRule)(ptr)
	var objs []BucketObjectLockConfigurationSpecRule
	if obj != nil {
		objs = []BucketObjectLockConfigurationSpecRule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketObjectLockConfigurationSpecRuleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketObjectLockConfigurationSpecRule)(ptr) = BucketObjectLockConfigurationSpecRule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketObjectLockConfigurationSpecRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketObjectLockConfigurationSpecRule)(ptr) = objs[0]
			} else {
				*(*BucketObjectLockConfigurationSpecRule)(ptr) = BucketObjectLockConfigurationSpecRule{}
			}
		} else {
			*(*BucketObjectLockConfigurationSpecRule)(ptr) = BucketObjectLockConfigurationSpecRule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketObjectLockConfigurationSpecRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketObjectLockConfigurationSpecRule)(ptr) = obj
		} else {
			*(*BucketObjectLockConfigurationSpecRule)(ptr) = BucketObjectLockConfigurationSpecRule{}
		}
	default:
		iter.ReportError("decode BucketObjectLockConfigurationSpecRule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketObjectLockConfigurationSpecRuleDefaultRetentionCodec struct {
}

func (BucketObjectLockConfigurationSpecRuleDefaultRetentionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketObjectLockConfigurationSpecRuleDefaultRetention)(ptr) == nil
}

func (BucketObjectLockConfigurationSpecRuleDefaultRetentionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketObjectLockConfigurationSpecRuleDefaultRetention)(ptr)
	var objs []BucketObjectLockConfigurationSpecRuleDefaultRetention
	if obj != nil {
		objs = []BucketObjectLockConfigurationSpecRuleDefaultRetention{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRuleDefaultRetention{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketObjectLockConfigurationSpecRuleDefaultRetentionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketObjectLockConfigurationSpecRuleDefaultRetention)(ptr) = BucketObjectLockConfigurationSpecRuleDefaultRetention{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketObjectLockConfigurationSpecRuleDefaultRetention

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRuleDefaultRetention{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketObjectLockConfigurationSpecRuleDefaultRetention)(ptr) = objs[0]
			} else {
				*(*BucketObjectLockConfigurationSpecRuleDefaultRetention)(ptr) = BucketObjectLockConfigurationSpecRuleDefaultRetention{}
			}
		} else {
			*(*BucketObjectLockConfigurationSpecRuleDefaultRetention)(ptr) = BucketObjectLockConfigurationSpecRuleDefaultRetention{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketObjectLockConfigurationSpecRuleDefaultRetention

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketObjectLockConfigurationSpecRuleDefaultRetention{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketObjectLockConfigurationSpecRuleDefaultRetention)(ptr) = obj
		} else {
			*(*BucketObjectLockConfigurationSpecRuleDefaultRetention)(ptr) = BucketObjectLockConfigurationSpecRuleDefaultRetention{}
		}
	default:
		iter.ReportError("decode BucketObjectLockConfigurationSpecRuleDefaultRetention", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketOwnershipControlsSpecRuleCodec struct {
}

func (BucketOwnershipControlsSpecRuleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketOwnershipControlsSpecRule)(ptr) == nil
}

func (BucketOwnershipControlsSpecRuleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketOwnershipControlsSpecRule)(ptr)
	var objs []BucketOwnershipControlsSpecRule
	if obj != nil {
		objs = []BucketOwnershipControlsSpecRule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketOwnershipControlsSpecRule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketOwnershipControlsSpecRuleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketOwnershipControlsSpecRule)(ptr) = BucketOwnershipControlsSpecRule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketOwnershipControlsSpecRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketOwnershipControlsSpecRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketOwnershipControlsSpecRule)(ptr) = objs[0]
			} else {
				*(*BucketOwnershipControlsSpecRule)(ptr) = BucketOwnershipControlsSpecRule{}
			}
		} else {
			*(*BucketOwnershipControlsSpecRule)(ptr) = BucketOwnershipControlsSpecRule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketOwnershipControlsSpecRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketOwnershipControlsSpecRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketOwnershipControlsSpecRule)(ptr) = obj
		} else {
			*(*BucketOwnershipControlsSpecRule)(ptr) = BucketOwnershipControlsSpecRule{}
		}
	default:
		iter.ReportError("decode BucketOwnershipControlsSpecRule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleDeleteMarkerReplicationCodec struct {
}

func (BucketReplicationConfigurationSpecRuleDeleteMarkerReplicationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleDeleteMarkerReplication)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleDeleteMarkerReplicationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleDeleteMarkerReplication)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleDeleteMarkerReplication
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleDeleteMarkerReplicationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleDeleteMarkerReplication)(ptr) = BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleDeleteMarkerReplication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleDeleteMarkerReplication)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleDeleteMarkerReplication)(ptr) = BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleDeleteMarkerReplication)(ptr) = BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleDeleteMarkerReplication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleDeleteMarkerReplication)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleDeleteMarkerReplication)(ptr) = BucketReplicationConfigurationSpecRuleDeleteMarkerReplication{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleDeleteMarkerReplication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleDestinationCodec struct {
}

func (BucketReplicationConfigurationSpecRuleDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleDestination)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleDestination)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleDestination
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleDestination)(ptr) = BucketReplicationConfigurationSpecRuleDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleDestination)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleDestination)(ptr) = BucketReplicationConfigurationSpecRuleDestination{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestination)(ptr) = BucketReplicationConfigurationSpecRuleDestination{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleDestination)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestination)(ptr) = BucketReplicationConfigurationSpecRuleDestination{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslationCodec struct {
}

func (BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation)(ptr) = BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation)(ptr) = BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation)(ptr) = BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation)(ptr) = BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleDestinationAccessControlTranslation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleDestinationEncryptionConfigurationCodec struct {
}

func (BucketReplicationConfigurationSpecRuleDestinationEncryptionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleDestinationEncryptionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleDestinationEncryptionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration)(ptr) = BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration)(ptr) = BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration)(ptr) = BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration)(ptr) = BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleDestinationEncryptionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleDestinationMetricsCodec struct {
}

func (BucketReplicationConfigurationSpecRuleDestinationMetricsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleDestinationMetrics)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleDestinationMetricsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleDestinationMetrics)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleDestinationMetrics
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleDestinationMetrics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetrics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleDestinationMetricsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleDestinationMetrics)(ptr) = BucketReplicationConfigurationSpecRuleDestinationMetrics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleDestinationMetrics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetrics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleDestinationMetrics)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleDestinationMetrics)(ptr) = BucketReplicationConfigurationSpecRuleDestinationMetrics{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationMetrics)(ptr) = BucketReplicationConfigurationSpecRuleDestinationMetrics{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleDestinationMetrics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetrics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleDestinationMetrics)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationMetrics)(ptr) = BucketReplicationConfigurationSpecRuleDestinationMetrics{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleDestinationMetrics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleDestinationMetricsEventThresholdCodec struct {
}

func (BucketReplicationConfigurationSpecRuleDestinationMetricsEventThresholdCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleDestinationMetricsEventThresholdCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleDestinationMetricsEventThresholdCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold)(ptr) = BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold)(ptr) = BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold)(ptr) = BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold)(ptr) = BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleDestinationMetricsEventThreshold", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleDestinationReplicationTimeCodec struct {
}

func (BucketReplicationConfigurationSpecRuleDestinationReplicationTimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleDestinationReplicationTime)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleDestinationReplicationTimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleDestinationReplicationTime)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleDestinationReplicationTime
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleDestinationReplicationTime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleDestinationReplicationTimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTime)(ptr) = BucketReplicationConfigurationSpecRuleDestinationReplicationTime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleDestinationReplicationTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTime)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTime)(ptr) = BucketReplicationConfigurationSpecRuleDestinationReplicationTime{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTime)(ptr) = BucketReplicationConfigurationSpecRuleDestinationReplicationTime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleDestinationReplicationTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTime)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTime)(ptr) = BucketReplicationConfigurationSpecRuleDestinationReplicationTime{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleDestinationReplicationTime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTimeCodec struct {
}

func (BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime)(ptr) = BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime)(ptr) = BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime)(ptr) = BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime)(ptr) = BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleDestinationReplicationTimeTime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleExistingObjectReplicationCodec struct {
}

func (BucketReplicationConfigurationSpecRuleExistingObjectReplicationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleExistingObjectReplication)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleExistingObjectReplicationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleExistingObjectReplication)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleExistingObjectReplication
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleExistingObjectReplication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleExistingObjectReplication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleExistingObjectReplicationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleExistingObjectReplication)(ptr) = BucketReplicationConfigurationSpecRuleExistingObjectReplication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleExistingObjectReplication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleExistingObjectReplication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleExistingObjectReplication)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleExistingObjectReplication)(ptr) = BucketReplicationConfigurationSpecRuleExistingObjectReplication{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleExistingObjectReplication)(ptr) = BucketReplicationConfigurationSpecRuleExistingObjectReplication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleExistingObjectReplication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleExistingObjectReplication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleExistingObjectReplication)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleExistingObjectReplication)(ptr) = BucketReplicationConfigurationSpecRuleExistingObjectReplication{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleExistingObjectReplication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleFilterCodec struct {
}

func (BucketReplicationConfigurationSpecRuleFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleFilter)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleFilter)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleFilter
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleFilter)(ptr) = BucketReplicationConfigurationSpecRuleFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleFilter)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleFilter)(ptr) = BucketReplicationConfigurationSpecRuleFilter{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleFilter)(ptr) = BucketReplicationConfigurationSpecRuleFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleFilter)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleFilter)(ptr) = BucketReplicationConfigurationSpecRuleFilter{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleFilterAndCodec struct {
}

func (BucketReplicationConfigurationSpecRuleFilterAndCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleFilterAnd)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleFilterAndCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleFilterAnd)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleFilterAnd
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleFilterAnd{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterAnd{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleFilterAndCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleFilterAnd)(ptr) = BucketReplicationConfigurationSpecRuleFilterAnd{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleFilterAnd

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterAnd{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleFilterAnd)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleFilterAnd)(ptr) = BucketReplicationConfigurationSpecRuleFilterAnd{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleFilterAnd)(ptr) = BucketReplicationConfigurationSpecRuleFilterAnd{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleFilterAnd

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterAnd{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleFilterAnd)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleFilterAnd)(ptr) = BucketReplicationConfigurationSpecRuleFilterAnd{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleFilterAnd", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleFilterTagCodec struct {
}

func (BucketReplicationConfigurationSpecRuleFilterTagCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleFilterTag)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleFilterTagCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleFilterTag)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleFilterTag
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleFilterTag{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterTag{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleFilterTagCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleFilterTag)(ptr) = BucketReplicationConfigurationSpecRuleFilterTag{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleFilterTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleFilterTag)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleFilterTag)(ptr) = BucketReplicationConfigurationSpecRuleFilterTag{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleFilterTag)(ptr) = BucketReplicationConfigurationSpecRuleFilterTag{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleFilterTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleFilterTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleFilterTag)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleFilterTag)(ptr) = BucketReplicationConfigurationSpecRuleFilterTag{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleFilterTag", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaCodec struct {
}

func (BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleSourceSelectionCriteria)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleSourceSelectionCriteria)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleSourceSelectionCriteria
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteria)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleSourceSelectionCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteria)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteria)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteria)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleSourceSelectionCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteria)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteria)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteria{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleSourceSelectionCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModificationsCodec struct {
}

func (BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModificationsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModificationsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModificationsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaReplicaModifications", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjectsCodec struct {
}

func (BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjectsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) == nil
}

func (BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjectsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr)
	var objs []BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects
	if obj != nil {
		objs = []BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjectsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = objs[0]
			} else {
				*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{}
			}
		} else {
			*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = obj
		} else {
			*(*BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects{}
		}
	default:
		iter.ReportError("decode BucketReplicationConfigurationSpecRuleSourceSelectionCriteriaSseKmsEncryptedObjects", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefaultCodec struct {
}

func (BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefaultCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault)(ptr) == nil
}

func (BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefaultCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault)(ptr)
	var objs []BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault
	if obj != nil {
		objs = []BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefaultCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault)(ptr) = BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault)(ptr) = objs[0]
			} else {
				*(*BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault)(ptr) = BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{}
			}
		} else {
			*(*BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault)(ptr) = BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault)(ptr) = obj
		} else {
			*(*BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault)(ptr) = BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault{}
		}
	default:
		iter.ReportError("decode BucketServerSideEncryptionConfigurationSpecRuleApplyServerSideEncryptionByDefault", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketVersioningSpecVersioningConfigurationCodec struct {
}

func (BucketVersioningSpecVersioningConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketVersioningSpecVersioningConfiguration)(ptr) == nil
}

func (BucketVersioningSpecVersioningConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketVersioningSpecVersioningConfiguration)(ptr)
	var objs []BucketVersioningSpecVersioningConfiguration
	if obj != nil {
		objs = []BucketVersioningSpecVersioningConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketVersioningSpecVersioningConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketVersioningSpecVersioningConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketVersioningSpecVersioningConfiguration)(ptr) = BucketVersioningSpecVersioningConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketVersioningSpecVersioningConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketVersioningSpecVersioningConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketVersioningSpecVersioningConfiguration)(ptr) = objs[0]
			} else {
				*(*BucketVersioningSpecVersioningConfiguration)(ptr) = BucketVersioningSpecVersioningConfiguration{}
			}
		} else {
			*(*BucketVersioningSpecVersioningConfiguration)(ptr) = BucketVersioningSpecVersioningConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketVersioningSpecVersioningConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketVersioningSpecVersioningConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketVersioningSpecVersioningConfiguration)(ptr) = obj
		} else {
			*(*BucketVersioningSpecVersioningConfiguration)(ptr) = BucketVersioningSpecVersioningConfiguration{}
		}
	default:
		iter.ReportError("decode BucketVersioningSpecVersioningConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketWebsiteConfigurationSpecErrorDocumentCodec struct {
}

func (BucketWebsiteConfigurationSpecErrorDocumentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketWebsiteConfigurationSpecErrorDocument)(ptr) == nil
}

func (BucketWebsiteConfigurationSpecErrorDocumentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketWebsiteConfigurationSpecErrorDocument)(ptr)
	var objs []BucketWebsiteConfigurationSpecErrorDocument
	if obj != nil {
		objs = []BucketWebsiteConfigurationSpecErrorDocument{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecErrorDocument{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketWebsiteConfigurationSpecErrorDocumentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketWebsiteConfigurationSpecErrorDocument)(ptr) = BucketWebsiteConfigurationSpecErrorDocument{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketWebsiteConfigurationSpecErrorDocument

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecErrorDocument{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketWebsiteConfigurationSpecErrorDocument)(ptr) = objs[0]
			} else {
				*(*BucketWebsiteConfigurationSpecErrorDocument)(ptr) = BucketWebsiteConfigurationSpecErrorDocument{}
			}
		} else {
			*(*BucketWebsiteConfigurationSpecErrorDocument)(ptr) = BucketWebsiteConfigurationSpecErrorDocument{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketWebsiteConfigurationSpecErrorDocument

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecErrorDocument{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketWebsiteConfigurationSpecErrorDocument)(ptr) = obj
		} else {
			*(*BucketWebsiteConfigurationSpecErrorDocument)(ptr) = BucketWebsiteConfigurationSpecErrorDocument{}
		}
	default:
		iter.ReportError("decode BucketWebsiteConfigurationSpecErrorDocument", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketWebsiteConfigurationSpecIndexDocumentCodec struct {
}

func (BucketWebsiteConfigurationSpecIndexDocumentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketWebsiteConfigurationSpecIndexDocument)(ptr) == nil
}

func (BucketWebsiteConfigurationSpecIndexDocumentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketWebsiteConfigurationSpecIndexDocument)(ptr)
	var objs []BucketWebsiteConfigurationSpecIndexDocument
	if obj != nil {
		objs = []BucketWebsiteConfigurationSpecIndexDocument{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecIndexDocument{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketWebsiteConfigurationSpecIndexDocumentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketWebsiteConfigurationSpecIndexDocument)(ptr) = BucketWebsiteConfigurationSpecIndexDocument{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketWebsiteConfigurationSpecIndexDocument

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecIndexDocument{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketWebsiteConfigurationSpecIndexDocument)(ptr) = objs[0]
			} else {
				*(*BucketWebsiteConfigurationSpecIndexDocument)(ptr) = BucketWebsiteConfigurationSpecIndexDocument{}
			}
		} else {
			*(*BucketWebsiteConfigurationSpecIndexDocument)(ptr) = BucketWebsiteConfigurationSpecIndexDocument{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketWebsiteConfigurationSpecIndexDocument

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecIndexDocument{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketWebsiteConfigurationSpecIndexDocument)(ptr) = obj
		} else {
			*(*BucketWebsiteConfigurationSpecIndexDocument)(ptr) = BucketWebsiteConfigurationSpecIndexDocument{}
		}
	default:
		iter.ReportError("decode BucketWebsiteConfigurationSpecIndexDocument", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketWebsiteConfigurationSpecRedirectAllRequestsToCodec struct {
}

func (BucketWebsiteConfigurationSpecRedirectAllRequestsToCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketWebsiteConfigurationSpecRedirectAllRequestsTo)(ptr) == nil
}

func (BucketWebsiteConfigurationSpecRedirectAllRequestsToCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketWebsiteConfigurationSpecRedirectAllRequestsTo)(ptr)
	var objs []BucketWebsiteConfigurationSpecRedirectAllRequestsTo
	if obj != nil {
		objs = []BucketWebsiteConfigurationSpecRedirectAllRequestsTo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRedirectAllRequestsTo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketWebsiteConfigurationSpecRedirectAllRequestsToCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketWebsiteConfigurationSpecRedirectAllRequestsTo)(ptr) = BucketWebsiteConfigurationSpecRedirectAllRequestsTo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketWebsiteConfigurationSpecRedirectAllRequestsTo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRedirectAllRequestsTo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketWebsiteConfigurationSpecRedirectAllRequestsTo)(ptr) = objs[0]
			} else {
				*(*BucketWebsiteConfigurationSpecRedirectAllRequestsTo)(ptr) = BucketWebsiteConfigurationSpecRedirectAllRequestsTo{}
			}
		} else {
			*(*BucketWebsiteConfigurationSpecRedirectAllRequestsTo)(ptr) = BucketWebsiteConfigurationSpecRedirectAllRequestsTo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketWebsiteConfigurationSpecRedirectAllRequestsTo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRedirectAllRequestsTo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketWebsiteConfigurationSpecRedirectAllRequestsTo)(ptr) = obj
		} else {
			*(*BucketWebsiteConfigurationSpecRedirectAllRequestsTo)(ptr) = BucketWebsiteConfigurationSpecRedirectAllRequestsTo{}
		}
	default:
		iter.ReportError("decode BucketWebsiteConfigurationSpecRedirectAllRequestsTo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketWebsiteConfigurationSpecRoutingRuleConditionCodec struct {
}

func (BucketWebsiteConfigurationSpecRoutingRuleConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketWebsiteConfigurationSpecRoutingRuleCondition)(ptr) == nil
}

func (BucketWebsiteConfigurationSpecRoutingRuleConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketWebsiteConfigurationSpecRoutingRuleCondition)(ptr)
	var objs []BucketWebsiteConfigurationSpecRoutingRuleCondition
	if obj != nil {
		objs = []BucketWebsiteConfigurationSpecRoutingRuleCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketWebsiteConfigurationSpecRoutingRuleConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketWebsiteConfigurationSpecRoutingRuleCondition)(ptr) = BucketWebsiteConfigurationSpecRoutingRuleCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketWebsiteConfigurationSpecRoutingRuleCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketWebsiteConfigurationSpecRoutingRuleCondition)(ptr) = objs[0]
			} else {
				*(*BucketWebsiteConfigurationSpecRoutingRuleCondition)(ptr) = BucketWebsiteConfigurationSpecRoutingRuleCondition{}
			}
		} else {
			*(*BucketWebsiteConfigurationSpecRoutingRuleCondition)(ptr) = BucketWebsiteConfigurationSpecRoutingRuleCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketWebsiteConfigurationSpecRoutingRuleCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketWebsiteConfigurationSpecRoutingRuleCondition)(ptr) = obj
		} else {
			*(*BucketWebsiteConfigurationSpecRoutingRuleCondition)(ptr) = BucketWebsiteConfigurationSpecRoutingRuleCondition{}
		}
	default:
		iter.ReportError("decode BucketWebsiteConfigurationSpecRoutingRuleCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketWebsiteConfigurationSpecRoutingRuleRedirectCodec struct {
}

func (BucketWebsiteConfigurationSpecRoutingRuleRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketWebsiteConfigurationSpecRoutingRuleRedirect)(ptr) == nil
}

func (BucketWebsiteConfigurationSpecRoutingRuleRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketWebsiteConfigurationSpecRoutingRuleRedirect)(ptr)
	var objs []BucketWebsiteConfigurationSpecRoutingRuleRedirect
	if obj != nil {
		objs = []BucketWebsiteConfigurationSpecRoutingRuleRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketWebsiteConfigurationSpecRoutingRuleRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketWebsiteConfigurationSpecRoutingRuleRedirect)(ptr) = BucketWebsiteConfigurationSpecRoutingRuleRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketWebsiteConfigurationSpecRoutingRuleRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketWebsiteConfigurationSpecRoutingRuleRedirect)(ptr) = objs[0]
			} else {
				*(*BucketWebsiteConfigurationSpecRoutingRuleRedirect)(ptr) = BucketWebsiteConfigurationSpecRoutingRuleRedirect{}
			}
		} else {
			*(*BucketWebsiteConfigurationSpecRoutingRuleRedirect)(ptr) = BucketWebsiteConfigurationSpecRoutingRuleRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BucketWebsiteConfigurationSpecRoutingRuleRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketWebsiteConfigurationSpecRoutingRuleRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BucketWebsiteConfigurationSpecRoutingRuleRedirect)(ptr) = obj
		} else {
			*(*BucketWebsiteConfigurationSpecRoutingRuleRedirect)(ptr) = BucketWebsiteConfigurationSpecRoutingRuleRedirect{}
		}
	default:
		iter.ReportError("decode BucketWebsiteConfigurationSpecRoutingRuleRedirect", "unexpected JSON type")
	}
}
