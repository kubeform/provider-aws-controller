/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParameters{}).Type1()):                         EventConnectionSpecAuthParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersApiKey{}).Type1()):                   EventConnectionSpecAuthParametersApiKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersBasic{}).Type1()):                    EventConnectionSpecAuthParametersBasicCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersInvocationHTTPParameters{}).Type1()): EventConnectionSpecAuthParametersInvocationHTTPParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauth{}).Type1()):                    EventConnectionSpecAuthParametersOauthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthClientParameters{}).Type1()):    EventConnectionSpecAuthParametersOauthClientParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthOauthHTTPParameters{}).Type1()): EventConnectionSpecAuthParametersOauthOauthHTTPParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventPermissionSpecCondition{}).Type1()):                              EventPermissionSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecBatchTarget{}).Type1()):                                EventTargetSpecBatchTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecDeadLetterConfig{}).Type1()):                           EventTargetSpecDeadLetterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTarget{}).Type1()):                                  EventTargetSpecEcsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTargetNetworkConfiguration{}).Type1()):              EventTargetSpecEcsTargetNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecHttpTarget{}).Type1()):                                 EventTargetSpecHttpTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecInputTransformer{}).Type1()):                           EventTargetSpecInputTransformerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecKinesisTarget{}).Type1()):                              EventTargetSpecKinesisTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRedshiftTarget{}).Type1()):                             EventTargetSpecRedshiftTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRetryPolicy{}).Type1()):                                EventTargetSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecSqsTarget{}).Type1()):                                  EventTargetSpecSqsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LogMetricFilterSpecMetricTransformation{}).Type1()):                   LogMetricFilterSpecMetricTransformationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricAlarmSpecMetricQueryMetric{}).Type1()):                          MetricAlarmSpecMetricQueryMetricCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParameters{}).Type1()):                         EventConnectionSpecAuthParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersApiKey{}).Type1()):                   EventConnectionSpecAuthParametersApiKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersBasic{}).Type1()):                    EventConnectionSpecAuthParametersBasicCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersInvocationHTTPParameters{}).Type1()): EventConnectionSpecAuthParametersInvocationHTTPParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauth{}).Type1()):                    EventConnectionSpecAuthParametersOauthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthClientParameters{}).Type1()):    EventConnectionSpecAuthParametersOauthClientParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthOauthHTTPParameters{}).Type1()): EventConnectionSpecAuthParametersOauthOauthHTTPParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventPermissionSpecCondition{}).Type1()):                              EventPermissionSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecBatchTarget{}).Type1()):                                EventTargetSpecBatchTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecDeadLetterConfig{}).Type1()):                           EventTargetSpecDeadLetterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTarget{}).Type1()):                                  EventTargetSpecEcsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTargetNetworkConfiguration{}).Type1()):              EventTargetSpecEcsTargetNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecHttpTarget{}).Type1()):                                 EventTargetSpecHttpTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecInputTransformer{}).Type1()):                           EventTargetSpecInputTransformerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecKinesisTarget{}).Type1()):                              EventTargetSpecKinesisTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRedshiftTarget{}).Type1()):                             EventTargetSpecRedshiftTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRetryPolicy{}).Type1()):                                EventTargetSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecSqsTarget{}).Type1()):                                  EventTargetSpecSqsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LogMetricFilterSpecMetricTransformation{}).Type1()):                   LogMetricFilterSpecMetricTransformationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricAlarmSpecMetricQueryMetric{}).Type1()):                          MetricAlarmSpecMetricQueryMetricCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type EventConnectionSpecAuthParametersCodec struct {
}

func (EventConnectionSpecAuthParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventConnectionSpecAuthParameters)(ptr) == nil
}

func (EventConnectionSpecAuthParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventConnectionSpecAuthParameters)(ptr)
	var objs []EventConnectionSpecAuthParameters
	if obj != nil {
		objs = []EventConnectionSpecAuthParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventConnectionSpecAuthParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventConnectionSpecAuthParameters)(ptr) = EventConnectionSpecAuthParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventConnectionSpecAuthParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventConnectionSpecAuthParameters)(ptr) = objs[0]
			} else {
				*(*EventConnectionSpecAuthParameters)(ptr) = EventConnectionSpecAuthParameters{}
			}
		} else {
			*(*EventConnectionSpecAuthParameters)(ptr) = EventConnectionSpecAuthParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventConnectionSpecAuthParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventConnectionSpecAuthParameters)(ptr) = obj
		} else {
			*(*EventConnectionSpecAuthParameters)(ptr) = EventConnectionSpecAuthParameters{}
		}
	default:
		iter.ReportError("decode EventConnectionSpecAuthParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventConnectionSpecAuthParametersApiKeyCodec struct {
}

func (EventConnectionSpecAuthParametersApiKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventConnectionSpecAuthParametersApiKey)(ptr) == nil
}

func (EventConnectionSpecAuthParametersApiKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventConnectionSpecAuthParametersApiKey)(ptr)
	var objs []EventConnectionSpecAuthParametersApiKey
	if obj != nil {
		objs = []EventConnectionSpecAuthParametersApiKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersApiKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventConnectionSpecAuthParametersApiKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventConnectionSpecAuthParametersApiKey)(ptr) = EventConnectionSpecAuthParametersApiKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventConnectionSpecAuthParametersApiKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersApiKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventConnectionSpecAuthParametersApiKey)(ptr) = objs[0]
			} else {
				*(*EventConnectionSpecAuthParametersApiKey)(ptr) = EventConnectionSpecAuthParametersApiKey{}
			}
		} else {
			*(*EventConnectionSpecAuthParametersApiKey)(ptr) = EventConnectionSpecAuthParametersApiKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventConnectionSpecAuthParametersApiKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersApiKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventConnectionSpecAuthParametersApiKey)(ptr) = obj
		} else {
			*(*EventConnectionSpecAuthParametersApiKey)(ptr) = EventConnectionSpecAuthParametersApiKey{}
		}
	default:
		iter.ReportError("decode EventConnectionSpecAuthParametersApiKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventConnectionSpecAuthParametersBasicCodec struct {
}

func (EventConnectionSpecAuthParametersBasicCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventConnectionSpecAuthParametersBasic)(ptr) == nil
}

func (EventConnectionSpecAuthParametersBasicCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventConnectionSpecAuthParametersBasic)(ptr)
	var objs []EventConnectionSpecAuthParametersBasic
	if obj != nil {
		objs = []EventConnectionSpecAuthParametersBasic{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersBasic{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventConnectionSpecAuthParametersBasicCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventConnectionSpecAuthParametersBasic)(ptr) = EventConnectionSpecAuthParametersBasic{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventConnectionSpecAuthParametersBasic

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersBasic{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventConnectionSpecAuthParametersBasic)(ptr) = objs[0]
			} else {
				*(*EventConnectionSpecAuthParametersBasic)(ptr) = EventConnectionSpecAuthParametersBasic{}
			}
		} else {
			*(*EventConnectionSpecAuthParametersBasic)(ptr) = EventConnectionSpecAuthParametersBasic{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventConnectionSpecAuthParametersBasic

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersBasic{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventConnectionSpecAuthParametersBasic)(ptr) = obj
		} else {
			*(*EventConnectionSpecAuthParametersBasic)(ptr) = EventConnectionSpecAuthParametersBasic{}
		}
	default:
		iter.ReportError("decode EventConnectionSpecAuthParametersBasic", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventConnectionSpecAuthParametersInvocationHTTPParametersCodec struct {
}

func (EventConnectionSpecAuthParametersInvocationHTTPParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventConnectionSpecAuthParametersInvocationHTTPParameters)(ptr) == nil
}

func (EventConnectionSpecAuthParametersInvocationHTTPParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventConnectionSpecAuthParametersInvocationHTTPParameters)(ptr)
	var objs []EventConnectionSpecAuthParametersInvocationHTTPParameters
	if obj != nil {
		objs = []EventConnectionSpecAuthParametersInvocationHTTPParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersInvocationHTTPParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventConnectionSpecAuthParametersInvocationHTTPParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventConnectionSpecAuthParametersInvocationHTTPParameters)(ptr) = EventConnectionSpecAuthParametersInvocationHTTPParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventConnectionSpecAuthParametersInvocationHTTPParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersInvocationHTTPParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventConnectionSpecAuthParametersInvocationHTTPParameters)(ptr) = objs[0]
			} else {
				*(*EventConnectionSpecAuthParametersInvocationHTTPParameters)(ptr) = EventConnectionSpecAuthParametersInvocationHTTPParameters{}
			}
		} else {
			*(*EventConnectionSpecAuthParametersInvocationHTTPParameters)(ptr) = EventConnectionSpecAuthParametersInvocationHTTPParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventConnectionSpecAuthParametersInvocationHTTPParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersInvocationHTTPParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventConnectionSpecAuthParametersInvocationHTTPParameters)(ptr) = obj
		} else {
			*(*EventConnectionSpecAuthParametersInvocationHTTPParameters)(ptr) = EventConnectionSpecAuthParametersInvocationHTTPParameters{}
		}
	default:
		iter.ReportError("decode EventConnectionSpecAuthParametersInvocationHTTPParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventConnectionSpecAuthParametersOauthCodec struct {
}

func (EventConnectionSpecAuthParametersOauthCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventConnectionSpecAuthParametersOauth)(ptr) == nil
}

func (EventConnectionSpecAuthParametersOauthCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventConnectionSpecAuthParametersOauth)(ptr)
	var objs []EventConnectionSpecAuthParametersOauth
	if obj != nil {
		objs = []EventConnectionSpecAuthParametersOauth{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauth{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventConnectionSpecAuthParametersOauthCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventConnectionSpecAuthParametersOauth)(ptr) = EventConnectionSpecAuthParametersOauth{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventConnectionSpecAuthParametersOauth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventConnectionSpecAuthParametersOauth)(ptr) = objs[0]
			} else {
				*(*EventConnectionSpecAuthParametersOauth)(ptr) = EventConnectionSpecAuthParametersOauth{}
			}
		} else {
			*(*EventConnectionSpecAuthParametersOauth)(ptr) = EventConnectionSpecAuthParametersOauth{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventConnectionSpecAuthParametersOauth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventConnectionSpecAuthParametersOauth)(ptr) = obj
		} else {
			*(*EventConnectionSpecAuthParametersOauth)(ptr) = EventConnectionSpecAuthParametersOauth{}
		}
	default:
		iter.ReportError("decode EventConnectionSpecAuthParametersOauth", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventConnectionSpecAuthParametersOauthClientParametersCodec struct {
}

func (EventConnectionSpecAuthParametersOauthClientParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventConnectionSpecAuthParametersOauthClientParameters)(ptr) == nil
}

func (EventConnectionSpecAuthParametersOauthClientParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventConnectionSpecAuthParametersOauthClientParameters)(ptr)
	var objs []EventConnectionSpecAuthParametersOauthClientParameters
	if obj != nil {
		objs = []EventConnectionSpecAuthParametersOauthClientParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthClientParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventConnectionSpecAuthParametersOauthClientParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventConnectionSpecAuthParametersOauthClientParameters)(ptr) = EventConnectionSpecAuthParametersOauthClientParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventConnectionSpecAuthParametersOauthClientParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthClientParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventConnectionSpecAuthParametersOauthClientParameters)(ptr) = objs[0]
			} else {
				*(*EventConnectionSpecAuthParametersOauthClientParameters)(ptr) = EventConnectionSpecAuthParametersOauthClientParameters{}
			}
		} else {
			*(*EventConnectionSpecAuthParametersOauthClientParameters)(ptr) = EventConnectionSpecAuthParametersOauthClientParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventConnectionSpecAuthParametersOauthClientParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthClientParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventConnectionSpecAuthParametersOauthClientParameters)(ptr) = obj
		} else {
			*(*EventConnectionSpecAuthParametersOauthClientParameters)(ptr) = EventConnectionSpecAuthParametersOauthClientParameters{}
		}
	default:
		iter.ReportError("decode EventConnectionSpecAuthParametersOauthClientParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventConnectionSpecAuthParametersOauthOauthHTTPParametersCodec struct {
}

func (EventConnectionSpecAuthParametersOauthOauthHTTPParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventConnectionSpecAuthParametersOauthOauthHTTPParameters)(ptr) == nil
}

func (EventConnectionSpecAuthParametersOauthOauthHTTPParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventConnectionSpecAuthParametersOauthOauthHTTPParameters)(ptr)
	var objs []EventConnectionSpecAuthParametersOauthOauthHTTPParameters
	if obj != nil {
		objs = []EventConnectionSpecAuthParametersOauthOauthHTTPParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthOauthHTTPParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventConnectionSpecAuthParametersOauthOauthHTTPParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventConnectionSpecAuthParametersOauthOauthHTTPParameters)(ptr) = EventConnectionSpecAuthParametersOauthOauthHTTPParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventConnectionSpecAuthParametersOauthOauthHTTPParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthOauthHTTPParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventConnectionSpecAuthParametersOauthOauthHTTPParameters)(ptr) = objs[0]
			} else {
				*(*EventConnectionSpecAuthParametersOauthOauthHTTPParameters)(ptr) = EventConnectionSpecAuthParametersOauthOauthHTTPParameters{}
			}
		} else {
			*(*EventConnectionSpecAuthParametersOauthOauthHTTPParameters)(ptr) = EventConnectionSpecAuthParametersOauthOauthHTTPParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventConnectionSpecAuthParametersOauthOauthHTTPParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventConnectionSpecAuthParametersOauthOauthHTTPParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventConnectionSpecAuthParametersOauthOauthHTTPParameters)(ptr) = obj
		} else {
			*(*EventConnectionSpecAuthParametersOauthOauthHTTPParameters)(ptr) = EventConnectionSpecAuthParametersOauthOauthHTTPParameters{}
		}
	default:
		iter.ReportError("decode EventConnectionSpecAuthParametersOauthOauthHTTPParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventPermissionSpecConditionCodec struct {
}

func (EventPermissionSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventPermissionSpecCondition)(ptr) == nil
}

func (EventPermissionSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventPermissionSpecCondition)(ptr)
	var objs []EventPermissionSpecCondition
	if obj != nil {
		objs = []EventPermissionSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventPermissionSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventPermissionSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventPermissionSpecCondition)(ptr) = EventPermissionSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventPermissionSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventPermissionSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventPermissionSpecCondition)(ptr) = objs[0]
			} else {
				*(*EventPermissionSpecCondition)(ptr) = EventPermissionSpecCondition{}
			}
		} else {
			*(*EventPermissionSpecCondition)(ptr) = EventPermissionSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventPermissionSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventPermissionSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventPermissionSpecCondition)(ptr) = obj
		} else {
			*(*EventPermissionSpecCondition)(ptr) = EventPermissionSpecCondition{}
		}
	default:
		iter.ReportError("decode EventPermissionSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecBatchTargetCodec struct {
}

func (EventTargetSpecBatchTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecBatchTarget)(ptr) == nil
}

func (EventTargetSpecBatchTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecBatchTarget)(ptr)
	var objs []EventTargetSpecBatchTarget
	if obj != nil {
		objs = []EventTargetSpecBatchTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecBatchTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecBatchTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecBatchTarget)(ptr) = EventTargetSpecBatchTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecBatchTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecBatchTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecBatchTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecBatchTarget)(ptr) = EventTargetSpecBatchTarget{}
			}
		} else {
			*(*EventTargetSpecBatchTarget)(ptr) = EventTargetSpecBatchTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecBatchTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecBatchTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecBatchTarget)(ptr) = obj
		} else {
			*(*EventTargetSpecBatchTarget)(ptr) = EventTargetSpecBatchTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecBatchTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecDeadLetterConfigCodec struct {
}

func (EventTargetSpecDeadLetterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecDeadLetterConfig)(ptr) == nil
}

func (EventTargetSpecDeadLetterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecDeadLetterConfig)(ptr)
	var objs []EventTargetSpecDeadLetterConfig
	if obj != nil {
		objs = []EventTargetSpecDeadLetterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecDeadLetterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecDeadLetterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecDeadLetterConfig)(ptr) = EventTargetSpecDeadLetterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecDeadLetterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecDeadLetterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecDeadLetterConfig)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecDeadLetterConfig)(ptr) = EventTargetSpecDeadLetterConfig{}
			}
		} else {
			*(*EventTargetSpecDeadLetterConfig)(ptr) = EventTargetSpecDeadLetterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecDeadLetterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecDeadLetterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecDeadLetterConfig)(ptr) = obj
		} else {
			*(*EventTargetSpecDeadLetterConfig)(ptr) = EventTargetSpecDeadLetterConfig{}
		}
	default:
		iter.ReportError("decode EventTargetSpecDeadLetterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecEcsTargetCodec struct {
}

func (EventTargetSpecEcsTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecEcsTarget)(ptr) == nil
}

func (EventTargetSpecEcsTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecEcsTarget)(ptr)
	var objs []EventTargetSpecEcsTarget
	if obj != nil {
		objs = []EventTargetSpecEcsTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecEcsTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecEcsTarget)(ptr) = EventTargetSpecEcsTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecEcsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecEcsTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecEcsTarget)(ptr) = EventTargetSpecEcsTarget{}
			}
		} else {
			*(*EventTargetSpecEcsTarget)(ptr) = EventTargetSpecEcsTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecEcsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecEcsTarget)(ptr) = obj
		} else {
			*(*EventTargetSpecEcsTarget)(ptr) = EventTargetSpecEcsTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecEcsTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecEcsTargetNetworkConfigurationCodec struct {
}

func (EventTargetSpecEcsTargetNetworkConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) == nil
}

func (EventTargetSpecEcsTargetNetworkConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecEcsTargetNetworkConfiguration)(ptr)
	var objs []EventTargetSpecEcsTargetNetworkConfiguration
	if obj != nil {
		objs = []EventTargetSpecEcsTargetNetworkConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTargetNetworkConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecEcsTargetNetworkConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = EventTargetSpecEcsTargetNetworkConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecEcsTargetNetworkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTargetNetworkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = EventTargetSpecEcsTargetNetworkConfiguration{}
			}
		} else {
			*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = EventTargetSpecEcsTargetNetworkConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecEcsTargetNetworkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTargetNetworkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = obj
		} else {
			*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = EventTargetSpecEcsTargetNetworkConfiguration{}
		}
	default:
		iter.ReportError("decode EventTargetSpecEcsTargetNetworkConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecHttpTargetCodec struct {
}

func (EventTargetSpecHttpTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecHttpTarget)(ptr) == nil
}

func (EventTargetSpecHttpTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecHttpTarget)(ptr)
	var objs []EventTargetSpecHttpTarget
	if obj != nil {
		objs = []EventTargetSpecHttpTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecHttpTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecHttpTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecHttpTarget)(ptr) = EventTargetSpecHttpTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecHttpTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecHttpTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecHttpTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecHttpTarget)(ptr) = EventTargetSpecHttpTarget{}
			}
		} else {
			*(*EventTargetSpecHttpTarget)(ptr) = EventTargetSpecHttpTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecHttpTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecHttpTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecHttpTarget)(ptr) = obj
		} else {
			*(*EventTargetSpecHttpTarget)(ptr) = EventTargetSpecHttpTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecHttpTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecInputTransformerCodec struct {
}

func (EventTargetSpecInputTransformerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecInputTransformer)(ptr) == nil
}

func (EventTargetSpecInputTransformerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecInputTransformer)(ptr)
	var objs []EventTargetSpecInputTransformer
	if obj != nil {
		objs = []EventTargetSpecInputTransformer{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecInputTransformer{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecInputTransformerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecInputTransformer)(ptr) = EventTargetSpecInputTransformer{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecInputTransformer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecInputTransformer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecInputTransformer)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecInputTransformer)(ptr) = EventTargetSpecInputTransformer{}
			}
		} else {
			*(*EventTargetSpecInputTransformer)(ptr) = EventTargetSpecInputTransformer{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecInputTransformer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecInputTransformer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecInputTransformer)(ptr) = obj
		} else {
			*(*EventTargetSpecInputTransformer)(ptr) = EventTargetSpecInputTransformer{}
		}
	default:
		iter.ReportError("decode EventTargetSpecInputTransformer", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecKinesisTargetCodec struct {
}

func (EventTargetSpecKinesisTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecKinesisTarget)(ptr) == nil
}

func (EventTargetSpecKinesisTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecKinesisTarget)(ptr)
	var objs []EventTargetSpecKinesisTarget
	if obj != nil {
		objs = []EventTargetSpecKinesisTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecKinesisTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecKinesisTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecKinesisTarget)(ptr) = EventTargetSpecKinesisTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecKinesisTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecKinesisTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecKinesisTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecKinesisTarget)(ptr) = EventTargetSpecKinesisTarget{}
			}
		} else {
			*(*EventTargetSpecKinesisTarget)(ptr) = EventTargetSpecKinesisTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecKinesisTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecKinesisTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecKinesisTarget)(ptr) = obj
		} else {
			*(*EventTargetSpecKinesisTarget)(ptr) = EventTargetSpecKinesisTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecKinesisTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecRedshiftTargetCodec struct {
}

func (EventTargetSpecRedshiftTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecRedshiftTarget)(ptr) == nil
}

func (EventTargetSpecRedshiftTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecRedshiftTarget)(ptr)
	var objs []EventTargetSpecRedshiftTarget
	if obj != nil {
		objs = []EventTargetSpecRedshiftTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRedshiftTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecRedshiftTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecRedshiftTarget)(ptr) = EventTargetSpecRedshiftTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecRedshiftTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRedshiftTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecRedshiftTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecRedshiftTarget)(ptr) = EventTargetSpecRedshiftTarget{}
			}
		} else {
			*(*EventTargetSpecRedshiftTarget)(ptr) = EventTargetSpecRedshiftTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecRedshiftTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRedshiftTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecRedshiftTarget)(ptr) = obj
		} else {
			*(*EventTargetSpecRedshiftTarget)(ptr) = EventTargetSpecRedshiftTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecRedshiftTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecRetryPolicyCodec struct {
}

func (EventTargetSpecRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecRetryPolicy)(ptr) == nil
}

func (EventTargetSpecRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecRetryPolicy)(ptr)
	var objs []EventTargetSpecRetryPolicy
	if obj != nil {
		objs = []EventTargetSpecRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecRetryPolicy)(ptr) = EventTargetSpecRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecRetryPolicy)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecRetryPolicy)(ptr) = EventTargetSpecRetryPolicy{}
			}
		} else {
			*(*EventTargetSpecRetryPolicy)(ptr) = EventTargetSpecRetryPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecRetryPolicy)(ptr) = obj
		} else {
			*(*EventTargetSpecRetryPolicy)(ptr) = EventTargetSpecRetryPolicy{}
		}
	default:
		iter.ReportError("decode EventTargetSpecRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecSqsTargetCodec struct {
}

func (EventTargetSpecSqsTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecSqsTarget)(ptr) == nil
}

func (EventTargetSpecSqsTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecSqsTarget)(ptr)
	var objs []EventTargetSpecSqsTarget
	if obj != nil {
		objs = []EventTargetSpecSqsTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecSqsTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecSqsTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecSqsTarget)(ptr) = EventTargetSpecSqsTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecSqsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecSqsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecSqsTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecSqsTarget)(ptr) = EventTargetSpecSqsTarget{}
			}
		} else {
			*(*EventTargetSpecSqsTarget)(ptr) = EventTargetSpecSqsTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventTargetSpecSqsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecSqsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventTargetSpecSqsTarget)(ptr) = obj
		} else {
			*(*EventTargetSpecSqsTarget)(ptr) = EventTargetSpecSqsTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecSqsTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LogMetricFilterSpecMetricTransformationCodec struct {
}

func (LogMetricFilterSpecMetricTransformationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LogMetricFilterSpecMetricTransformation)(ptr) == nil
}

func (LogMetricFilterSpecMetricTransformationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LogMetricFilterSpecMetricTransformation)(ptr)
	var objs []LogMetricFilterSpecMetricTransformation
	if obj != nil {
		objs = []LogMetricFilterSpecMetricTransformation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LogMetricFilterSpecMetricTransformation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LogMetricFilterSpecMetricTransformationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LogMetricFilterSpecMetricTransformation)(ptr) = LogMetricFilterSpecMetricTransformation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LogMetricFilterSpecMetricTransformation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LogMetricFilterSpecMetricTransformation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LogMetricFilterSpecMetricTransformation)(ptr) = objs[0]
			} else {
				*(*LogMetricFilterSpecMetricTransformation)(ptr) = LogMetricFilterSpecMetricTransformation{}
			}
		} else {
			*(*LogMetricFilterSpecMetricTransformation)(ptr) = LogMetricFilterSpecMetricTransformation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LogMetricFilterSpecMetricTransformation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LogMetricFilterSpecMetricTransformation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LogMetricFilterSpecMetricTransformation)(ptr) = obj
		} else {
			*(*LogMetricFilterSpecMetricTransformation)(ptr) = LogMetricFilterSpecMetricTransformation{}
		}
	default:
		iter.ReportError("decode LogMetricFilterSpecMetricTransformation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricAlarmSpecMetricQueryMetricCodec struct {
}

func (MetricAlarmSpecMetricQueryMetricCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricAlarmSpecMetricQueryMetric)(ptr) == nil
}

func (MetricAlarmSpecMetricQueryMetricCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricAlarmSpecMetricQueryMetric)(ptr)
	var objs []MetricAlarmSpecMetricQueryMetric
	if obj != nil {
		objs = []MetricAlarmSpecMetricQueryMetric{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricAlarmSpecMetricQueryMetric{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricAlarmSpecMetricQueryMetricCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricAlarmSpecMetricQueryMetric)(ptr) = MetricAlarmSpecMetricQueryMetric{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricAlarmSpecMetricQueryMetric

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricAlarmSpecMetricQueryMetric{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricAlarmSpecMetricQueryMetric)(ptr) = objs[0]
			} else {
				*(*MetricAlarmSpecMetricQueryMetric)(ptr) = MetricAlarmSpecMetricQueryMetric{}
			}
		} else {
			*(*MetricAlarmSpecMetricQueryMetric)(ptr) = MetricAlarmSpecMetricQueryMetric{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MetricAlarmSpecMetricQueryMetric

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricAlarmSpecMetricQueryMetric{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MetricAlarmSpecMetricQueryMetric)(ptr) = obj
		} else {
			*(*MetricAlarmSpecMetricQueryMetric)(ptr) = MetricAlarmSpecMetricQueryMetric{}
		}
	default:
		iter.ReportError("decode MetricAlarmSpecMetricQueryMetric", "unexpected JSON type")
	}
}
