/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}).Type1()):                               CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}).Type1()):                  CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}).Type1()):           CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}).Type1()):                  CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}).Type1()):           CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}).Type1()):             CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}).Type1()): CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehavior{}).Type1()):                                                  DistributionSpecDefaultCacheBehaviorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValues{}).Type1()):                                   DistributionSpecDefaultCacheBehaviorForwardedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}).Type1()):                            DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecLoggingConfig{}).Type1()):                                                         DistributionSpecLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValues{}).Type1()):                                   DistributionSpecOrderedCacheBehaviorForwardedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}).Type1()):                            DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginCustomOriginConfig{}).Type1()):                                              DistributionSpecOriginCustomOriginConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginOriginShield{}).Type1()):                                                    DistributionSpecOriginOriginShieldCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginS3OriginConfig{}).Type1()):                                                  DistributionSpecOriginS3OriginConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginGroupFailoverCriteria{}).Type1()):                                           DistributionSpecOriginGroupFailoverCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictions{}).Type1()):                                                          DistributionSpecRestrictionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictionsGeoRestriction{}).Type1()):                                            DistributionSpecRestrictionsGeoRestrictionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecViewerCertificate{}).Type1()):                                                     DistributionSpecViewerCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfig{}).Type1()):                                FieldLevelEncryptionConfigSpecContentTypeProfileConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{}).Type1()):             FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfilesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfig{}).Type1()):                                   FieldLevelEncryptionConfigSpecQueryArgProfileConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{}).Type1()):                   FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfilesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntities{}).Type1()):                                     FieldLevelEncryptionProfileSpecEncryptionEntitiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{}).Type1()):                   FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatternsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscription{}).Type1()):                                      MonitoringSubscriptionSpecMonitoringSubscriptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{}).Type1()):     MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfig{}).Type1()):                                                  OriginRequestPolicySpecCookiesConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfigCookies{}).Type1()):                                           OriginRequestPolicySpecCookiesConfigCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfig{}).Type1()):                                                  OriginRequestPolicySpecHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfigHeaders{}).Type1()):                                           OriginRequestPolicySpecHeadersConfigHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfig{}).Type1()):                                             OriginRequestPolicySpecQueryStringsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfigQueryStrings{}).Type1()):                                 OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpoint{}).Type1()):                                                         RealtimeLogConfigSpecEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpointKinesisStreamConfig{}).Type1()):                                      RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfig{}).Type1()):                                                   ResponseHeadersPolicySpecCorsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{}).Type1()):                          ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{}).Type1()):                          ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethodsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{}).Type1()):                          ResponseHeadersPolicySpecCorsConfigAccessControlAllowOriginsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{}).Type1()):                         ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCustomHeadersConfig{}).Type1()):                                          ResponseHeadersPolicySpecCustomHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfig{}).Type1()):                                        ResponseHeadersPolicySpecSecurityHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{}).Type1()):                   ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{}).Type1()):                      ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{}).Type1()):                            ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{}).Type1()):                          ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{}).Type1()):                 ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{}).Type1()):                           ResponseHeadersPolicySpecSecurityHeadersConfigXssProtectionCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}).Type1()):                               CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}).Type1()):                  CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}).Type1()):           CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}).Type1()):                  CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}).Type1()):           CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}).Type1()):             CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}).Type1()): CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehavior{}).Type1()):                                                  DistributionSpecDefaultCacheBehaviorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValues{}).Type1()):                                   DistributionSpecDefaultCacheBehaviorForwardedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}).Type1()):                            DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecLoggingConfig{}).Type1()):                                                         DistributionSpecLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValues{}).Type1()):                                   DistributionSpecOrderedCacheBehaviorForwardedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}).Type1()):                            DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginCustomOriginConfig{}).Type1()):                                              DistributionSpecOriginCustomOriginConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginOriginShield{}).Type1()):                                                    DistributionSpecOriginOriginShieldCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginS3OriginConfig{}).Type1()):                                                  DistributionSpecOriginS3OriginConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginGroupFailoverCriteria{}).Type1()):                                           DistributionSpecOriginGroupFailoverCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictions{}).Type1()):                                                          DistributionSpecRestrictionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictionsGeoRestriction{}).Type1()):                                            DistributionSpecRestrictionsGeoRestrictionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecViewerCertificate{}).Type1()):                                                     DistributionSpecViewerCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfig{}).Type1()):                                FieldLevelEncryptionConfigSpecContentTypeProfileConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{}).Type1()):             FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfilesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfig{}).Type1()):                                   FieldLevelEncryptionConfigSpecQueryArgProfileConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{}).Type1()):                   FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfilesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntities{}).Type1()):                                     FieldLevelEncryptionProfileSpecEncryptionEntitiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{}).Type1()):                   FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatternsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscription{}).Type1()):                                      MonitoringSubscriptionSpecMonitoringSubscriptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{}).Type1()):     MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfig{}).Type1()):                                                  OriginRequestPolicySpecCookiesConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfigCookies{}).Type1()):                                           OriginRequestPolicySpecCookiesConfigCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfig{}).Type1()):                                                  OriginRequestPolicySpecHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfigHeaders{}).Type1()):                                           OriginRequestPolicySpecHeadersConfigHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfig{}).Type1()):                                             OriginRequestPolicySpecQueryStringsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfigQueryStrings{}).Type1()):                                 OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpoint{}).Type1()):                                                         RealtimeLogConfigSpecEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpointKinesisStreamConfig{}).Type1()):                                      RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfig{}).Type1()):                                                   ResponseHeadersPolicySpecCorsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{}).Type1()):                          ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{}).Type1()):                          ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethodsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{}).Type1()):                          ResponseHeadersPolicySpecCorsConfigAccessControlAllowOriginsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{}).Type1()):                         ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCustomHeadersConfig{}).Type1()):                                          ResponseHeadersPolicySpecCustomHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfig{}).Type1()):                                        ResponseHeadersPolicySpecSecurityHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{}).Type1()):                   ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{}).Type1()):                      ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{}).Type1()):                            ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{}).Type1()):                          ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{}).Type1()):                 ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{}).Type1()):                           ResponseHeadersPolicySpecSecurityHeadersConfigXssProtectionCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOrigin
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOrigin

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CachePolicySpecParametersInCacheKeyAndForwardedToOrigin

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = obj
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOrigin", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = obj
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = obj
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = obj
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = obj
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = obj
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = obj
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecDefaultCacheBehaviorCodec struct {
}

func (DistributionSpecDefaultCacheBehaviorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecDefaultCacheBehavior)(ptr) == nil
}

func (DistributionSpecDefaultCacheBehaviorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecDefaultCacheBehavior)(ptr)
	var objs []DistributionSpecDefaultCacheBehavior
	if obj != nil {
		objs = []DistributionSpecDefaultCacheBehavior{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehavior{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecDefaultCacheBehaviorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecDefaultCacheBehavior)(ptr) = DistributionSpecDefaultCacheBehavior{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecDefaultCacheBehavior

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehavior{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecDefaultCacheBehavior)(ptr) = objs[0]
			} else {
				*(*DistributionSpecDefaultCacheBehavior)(ptr) = DistributionSpecDefaultCacheBehavior{}
			}
		} else {
			*(*DistributionSpecDefaultCacheBehavior)(ptr) = DistributionSpecDefaultCacheBehavior{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecDefaultCacheBehavior

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehavior{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecDefaultCacheBehavior)(ptr) = obj
		} else {
			*(*DistributionSpecDefaultCacheBehavior)(ptr) = DistributionSpecDefaultCacheBehavior{}
		}
	default:
		iter.ReportError("decode DistributionSpecDefaultCacheBehavior", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecDefaultCacheBehaviorForwardedValuesCodec struct {
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) == nil
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr)
	var objs []DistributionSpecDefaultCacheBehaviorForwardedValues
	if obj != nil {
		objs = []DistributionSpecDefaultCacheBehaviorForwardedValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecDefaultCacheBehaviorForwardedValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = objs[0]
			} else {
				*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValues{}
			}
		} else {
			*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValues{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecDefaultCacheBehaviorForwardedValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = obj
		} else {
			*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValues{}
		}
	default:
		iter.ReportError("decode DistributionSpecDefaultCacheBehaviorForwardedValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec struct {
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) == nil
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr)
	var objs []DistributionSpecDefaultCacheBehaviorForwardedValuesCookies
	if obj != nil {
		objs = []DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecDefaultCacheBehaviorForwardedValuesCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = objs[0]
			} else {
				*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}
			}
		} else {
			*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecDefaultCacheBehaviorForwardedValuesCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = obj
		} else {
			*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}
		}
	default:
		iter.ReportError("decode DistributionSpecDefaultCacheBehaviorForwardedValuesCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecLoggingConfigCodec struct {
}

func (DistributionSpecLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecLoggingConfig)(ptr) == nil
}

func (DistributionSpecLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecLoggingConfig)(ptr)
	var objs []DistributionSpecLoggingConfig
	if obj != nil {
		objs = []DistributionSpecLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecLoggingConfig)(ptr) = DistributionSpecLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecLoggingConfig)(ptr) = objs[0]
			} else {
				*(*DistributionSpecLoggingConfig)(ptr) = DistributionSpecLoggingConfig{}
			}
		} else {
			*(*DistributionSpecLoggingConfig)(ptr) = DistributionSpecLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecLoggingConfig)(ptr) = obj
		} else {
			*(*DistributionSpecLoggingConfig)(ptr) = DistributionSpecLoggingConfig{}
		}
	default:
		iter.ReportError("decode DistributionSpecLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOrderedCacheBehaviorForwardedValuesCodec struct {
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) == nil
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr)
	var objs []DistributionSpecOrderedCacheBehaviorForwardedValues
	if obj != nil {
		objs = []DistributionSpecOrderedCacheBehaviorForwardedValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOrderedCacheBehaviorForwardedValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValues{}
			}
		} else {
			*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValues{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecOrderedCacheBehaviorForwardedValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = obj
		} else {
			*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValues{}
		}
	default:
		iter.ReportError("decode DistributionSpecOrderedCacheBehaviorForwardedValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec struct {
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) == nil
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr)
	var objs []DistributionSpecOrderedCacheBehaviorForwardedValuesCookies
	if obj != nil {
		objs = []DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOrderedCacheBehaviorForwardedValuesCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}
			}
		} else {
			*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecOrderedCacheBehaviorForwardedValuesCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = obj
		} else {
			*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}
		}
	default:
		iter.ReportError("decode DistributionSpecOrderedCacheBehaviorForwardedValuesCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOriginCustomOriginConfigCodec struct {
}

func (DistributionSpecOriginCustomOriginConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOriginCustomOriginConfig)(ptr) == nil
}

func (DistributionSpecOriginCustomOriginConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOriginCustomOriginConfig)(ptr)
	var objs []DistributionSpecOriginCustomOriginConfig
	if obj != nil {
		objs = []DistributionSpecOriginCustomOriginConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginCustomOriginConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOriginCustomOriginConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOriginCustomOriginConfig)(ptr) = DistributionSpecOriginCustomOriginConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOriginCustomOriginConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginCustomOriginConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOriginCustomOriginConfig)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOriginCustomOriginConfig)(ptr) = DistributionSpecOriginCustomOriginConfig{}
			}
		} else {
			*(*DistributionSpecOriginCustomOriginConfig)(ptr) = DistributionSpecOriginCustomOriginConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecOriginCustomOriginConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginCustomOriginConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecOriginCustomOriginConfig)(ptr) = obj
		} else {
			*(*DistributionSpecOriginCustomOriginConfig)(ptr) = DistributionSpecOriginCustomOriginConfig{}
		}
	default:
		iter.ReportError("decode DistributionSpecOriginCustomOriginConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOriginOriginShieldCodec struct {
}

func (DistributionSpecOriginOriginShieldCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOriginOriginShield)(ptr) == nil
}

func (DistributionSpecOriginOriginShieldCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOriginOriginShield)(ptr)
	var objs []DistributionSpecOriginOriginShield
	if obj != nil {
		objs = []DistributionSpecOriginOriginShield{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginOriginShield{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOriginOriginShieldCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOriginOriginShield)(ptr) = DistributionSpecOriginOriginShield{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOriginOriginShield

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginOriginShield{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOriginOriginShield)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOriginOriginShield)(ptr) = DistributionSpecOriginOriginShield{}
			}
		} else {
			*(*DistributionSpecOriginOriginShield)(ptr) = DistributionSpecOriginOriginShield{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecOriginOriginShield

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginOriginShield{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecOriginOriginShield)(ptr) = obj
		} else {
			*(*DistributionSpecOriginOriginShield)(ptr) = DistributionSpecOriginOriginShield{}
		}
	default:
		iter.ReportError("decode DistributionSpecOriginOriginShield", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOriginS3OriginConfigCodec struct {
}

func (DistributionSpecOriginS3OriginConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOriginS3OriginConfig)(ptr) == nil
}

func (DistributionSpecOriginS3OriginConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOriginS3OriginConfig)(ptr)
	var objs []DistributionSpecOriginS3OriginConfig
	if obj != nil {
		objs = []DistributionSpecOriginS3OriginConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginS3OriginConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOriginS3OriginConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOriginS3OriginConfig)(ptr) = DistributionSpecOriginS3OriginConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOriginS3OriginConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginS3OriginConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOriginS3OriginConfig)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOriginS3OriginConfig)(ptr) = DistributionSpecOriginS3OriginConfig{}
			}
		} else {
			*(*DistributionSpecOriginS3OriginConfig)(ptr) = DistributionSpecOriginS3OriginConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecOriginS3OriginConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginS3OriginConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecOriginS3OriginConfig)(ptr) = obj
		} else {
			*(*DistributionSpecOriginS3OriginConfig)(ptr) = DistributionSpecOriginS3OriginConfig{}
		}
	default:
		iter.ReportError("decode DistributionSpecOriginS3OriginConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOriginGroupFailoverCriteriaCodec struct {
}

func (DistributionSpecOriginGroupFailoverCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOriginGroupFailoverCriteria)(ptr) == nil
}

func (DistributionSpecOriginGroupFailoverCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOriginGroupFailoverCriteria)(ptr)
	var objs []DistributionSpecOriginGroupFailoverCriteria
	if obj != nil {
		objs = []DistributionSpecOriginGroupFailoverCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginGroupFailoverCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOriginGroupFailoverCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = DistributionSpecOriginGroupFailoverCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOriginGroupFailoverCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginGroupFailoverCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = DistributionSpecOriginGroupFailoverCriteria{}
			}
		} else {
			*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = DistributionSpecOriginGroupFailoverCriteria{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecOriginGroupFailoverCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginGroupFailoverCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = obj
		} else {
			*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = DistributionSpecOriginGroupFailoverCriteria{}
		}
	default:
		iter.ReportError("decode DistributionSpecOriginGroupFailoverCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecRestrictionsCodec struct {
}

func (DistributionSpecRestrictionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecRestrictions)(ptr) == nil
}

func (DistributionSpecRestrictionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecRestrictions)(ptr)
	var objs []DistributionSpecRestrictions
	if obj != nil {
		objs = []DistributionSpecRestrictions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecRestrictionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecRestrictions)(ptr) = DistributionSpecRestrictions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecRestrictions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecRestrictions)(ptr) = objs[0]
			} else {
				*(*DistributionSpecRestrictions)(ptr) = DistributionSpecRestrictions{}
			}
		} else {
			*(*DistributionSpecRestrictions)(ptr) = DistributionSpecRestrictions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecRestrictions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecRestrictions)(ptr) = obj
		} else {
			*(*DistributionSpecRestrictions)(ptr) = DistributionSpecRestrictions{}
		}
	default:
		iter.ReportError("decode DistributionSpecRestrictions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecRestrictionsGeoRestrictionCodec struct {
}

func (DistributionSpecRestrictionsGeoRestrictionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecRestrictionsGeoRestriction)(ptr) == nil
}

func (DistributionSpecRestrictionsGeoRestrictionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecRestrictionsGeoRestriction)(ptr)
	var objs []DistributionSpecRestrictionsGeoRestriction
	if obj != nil {
		objs = []DistributionSpecRestrictionsGeoRestriction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictionsGeoRestriction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecRestrictionsGeoRestrictionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = DistributionSpecRestrictionsGeoRestriction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecRestrictionsGeoRestriction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictionsGeoRestriction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = objs[0]
			} else {
				*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = DistributionSpecRestrictionsGeoRestriction{}
			}
		} else {
			*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = DistributionSpecRestrictionsGeoRestriction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecRestrictionsGeoRestriction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictionsGeoRestriction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = obj
		} else {
			*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = DistributionSpecRestrictionsGeoRestriction{}
		}
	default:
		iter.ReportError("decode DistributionSpecRestrictionsGeoRestriction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecViewerCertificateCodec struct {
}

func (DistributionSpecViewerCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecViewerCertificate)(ptr) == nil
}

func (DistributionSpecViewerCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecViewerCertificate)(ptr)
	var objs []DistributionSpecViewerCertificate
	if obj != nil {
		objs = []DistributionSpecViewerCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecViewerCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecViewerCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecViewerCertificate)(ptr) = DistributionSpecViewerCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecViewerCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecViewerCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecViewerCertificate)(ptr) = objs[0]
			} else {
				*(*DistributionSpecViewerCertificate)(ptr) = DistributionSpecViewerCertificate{}
			}
		} else {
			*(*DistributionSpecViewerCertificate)(ptr) = DistributionSpecViewerCertificate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DistributionSpecViewerCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecViewerCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DistributionSpecViewerCertificate)(ptr) = obj
		} else {
			*(*DistributionSpecViewerCertificate)(ptr) = DistributionSpecViewerCertificate{}
		}
	default:
		iter.ReportError("decode DistributionSpecViewerCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FieldLevelEncryptionConfigSpecContentTypeProfileConfigCodec struct {
}

func (FieldLevelEncryptionConfigSpecContentTypeProfileConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FieldLevelEncryptionConfigSpecContentTypeProfileConfig)(ptr) == nil
}

func (FieldLevelEncryptionConfigSpecContentTypeProfileConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FieldLevelEncryptionConfigSpecContentTypeProfileConfig)(ptr)
	var objs []FieldLevelEncryptionConfigSpecContentTypeProfileConfig
	if obj != nil {
		objs = []FieldLevelEncryptionConfigSpecContentTypeProfileConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FieldLevelEncryptionConfigSpecContentTypeProfileConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfig)(ptr) = FieldLevelEncryptionConfigSpecContentTypeProfileConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FieldLevelEncryptionConfigSpecContentTypeProfileConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfig)(ptr) = objs[0]
			} else {
				*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfig)(ptr) = FieldLevelEncryptionConfigSpecContentTypeProfileConfig{}
			}
		} else {
			*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfig)(ptr) = FieldLevelEncryptionConfigSpecContentTypeProfileConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FieldLevelEncryptionConfigSpecContentTypeProfileConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfig)(ptr) = obj
		} else {
			*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfig)(ptr) = FieldLevelEncryptionConfigSpecContentTypeProfileConfig{}
		}
	default:
		iter.ReportError("decode FieldLevelEncryptionConfigSpecContentTypeProfileConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfilesCodec struct {
}

func (FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfilesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles)(ptr) == nil
}

func (FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfilesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles)(ptr)
	var objs []FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles
	if obj != nil {
		objs = []FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfilesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles)(ptr) = FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles)(ptr) = objs[0]
			} else {
				*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles)(ptr) = FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{}
			}
		} else {
			*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles)(ptr) = FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles)(ptr) = obj
		} else {
			*(*FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles)(ptr) = FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles{}
		}
	default:
		iter.ReportError("decode FieldLevelEncryptionConfigSpecContentTypeProfileConfigContentTypeProfiles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FieldLevelEncryptionConfigSpecQueryArgProfileConfigCodec struct {
}

func (FieldLevelEncryptionConfigSpecQueryArgProfileConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FieldLevelEncryptionConfigSpecQueryArgProfileConfig)(ptr) == nil
}

func (FieldLevelEncryptionConfigSpecQueryArgProfileConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FieldLevelEncryptionConfigSpecQueryArgProfileConfig)(ptr)
	var objs []FieldLevelEncryptionConfigSpecQueryArgProfileConfig
	if obj != nil {
		objs = []FieldLevelEncryptionConfigSpecQueryArgProfileConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FieldLevelEncryptionConfigSpecQueryArgProfileConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfig)(ptr) = FieldLevelEncryptionConfigSpecQueryArgProfileConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FieldLevelEncryptionConfigSpecQueryArgProfileConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfig)(ptr) = objs[0]
			} else {
				*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfig)(ptr) = FieldLevelEncryptionConfigSpecQueryArgProfileConfig{}
			}
		} else {
			*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfig)(ptr) = FieldLevelEncryptionConfigSpecQueryArgProfileConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FieldLevelEncryptionConfigSpecQueryArgProfileConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfig)(ptr) = obj
		} else {
			*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfig)(ptr) = FieldLevelEncryptionConfigSpecQueryArgProfileConfig{}
		}
	default:
		iter.ReportError("decode FieldLevelEncryptionConfigSpecQueryArgProfileConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfilesCodec struct {
}

func (FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfilesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles)(ptr) == nil
}

func (FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfilesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles)(ptr)
	var objs []FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles
	if obj != nil {
		objs = []FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfilesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles)(ptr) = FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles)(ptr) = objs[0]
			} else {
				*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles)(ptr) = FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{}
			}
		} else {
			*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles)(ptr) = FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles)(ptr) = obj
		} else {
			*(*FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles)(ptr) = FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles{}
		}
	default:
		iter.ReportError("decode FieldLevelEncryptionConfigSpecQueryArgProfileConfigQueryArgProfiles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FieldLevelEncryptionProfileSpecEncryptionEntitiesCodec struct {
}

func (FieldLevelEncryptionProfileSpecEncryptionEntitiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FieldLevelEncryptionProfileSpecEncryptionEntities)(ptr) == nil
}

func (FieldLevelEncryptionProfileSpecEncryptionEntitiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FieldLevelEncryptionProfileSpecEncryptionEntities)(ptr)
	var objs []FieldLevelEncryptionProfileSpecEncryptionEntities
	if obj != nil {
		objs = []FieldLevelEncryptionProfileSpecEncryptionEntities{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntities{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FieldLevelEncryptionProfileSpecEncryptionEntitiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FieldLevelEncryptionProfileSpecEncryptionEntities)(ptr) = FieldLevelEncryptionProfileSpecEncryptionEntities{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FieldLevelEncryptionProfileSpecEncryptionEntities

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntities{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FieldLevelEncryptionProfileSpecEncryptionEntities)(ptr) = objs[0]
			} else {
				*(*FieldLevelEncryptionProfileSpecEncryptionEntities)(ptr) = FieldLevelEncryptionProfileSpecEncryptionEntities{}
			}
		} else {
			*(*FieldLevelEncryptionProfileSpecEncryptionEntities)(ptr) = FieldLevelEncryptionProfileSpecEncryptionEntities{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FieldLevelEncryptionProfileSpecEncryptionEntities

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntities{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FieldLevelEncryptionProfileSpecEncryptionEntities)(ptr) = obj
		} else {
			*(*FieldLevelEncryptionProfileSpecEncryptionEntities)(ptr) = FieldLevelEncryptionProfileSpecEncryptionEntities{}
		}
	default:
		iter.ReportError("decode FieldLevelEncryptionProfileSpecEncryptionEntities", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatternsCodec struct {
}

func (FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatternsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns)(ptr) == nil
}

func (FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatternsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns)(ptr)
	var objs []FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns
	if obj != nil {
		objs = []FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatternsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns)(ptr) = FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns)(ptr) = objs[0]
			} else {
				*(*FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns)(ptr) = FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{}
			}
		} else {
			*(*FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns)(ptr) = FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns)(ptr) = obj
		} else {
			*(*FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns)(ptr) = FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns{}
		}
	default:
		iter.ReportError("decode FieldLevelEncryptionProfileSpecEncryptionEntitiesItemsFieldPatterns", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitoringSubscriptionSpecMonitoringSubscriptionCodec struct {
}

func (MonitoringSubscriptionSpecMonitoringSubscriptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitoringSubscriptionSpecMonitoringSubscription)(ptr) == nil
}

func (MonitoringSubscriptionSpecMonitoringSubscriptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitoringSubscriptionSpecMonitoringSubscription)(ptr)
	var objs []MonitoringSubscriptionSpecMonitoringSubscription
	if obj != nil {
		objs = []MonitoringSubscriptionSpecMonitoringSubscription{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscription{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitoringSubscriptionSpecMonitoringSubscriptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitoringSubscriptionSpecMonitoringSubscription)(ptr) = MonitoringSubscriptionSpecMonitoringSubscription{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitoringSubscriptionSpecMonitoringSubscription

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscription{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitoringSubscriptionSpecMonitoringSubscription)(ptr) = objs[0]
			} else {
				*(*MonitoringSubscriptionSpecMonitoringSubscription)(ptr) = MonitoringSubscriptionSpecMonitoringSubscription{}
			}
		} else {
			*(*MonitoringSubscriptionSpecMonitoringSubscription)(ptr) = MonitoringSubscriptionSpecMonitoringSubscription{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitoringSubscriptionSpecMonitoringSubscription

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscription{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitoringSubscriptionSpecMonitoringSubscription)(ptr) = obj
		} else {
			*(*MonitoringSubscriptionSpecMonitoringSubscription)(ptr) = MonitoringSubscriptionSpecMonitoringSubscription{}
		}
	default:
		iter.ReportError("decode MonitoringSubscriptionSpecMonitoringSubscription", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfigCodec struct {
}

func (MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig)(ptr) == nil
}

func (MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig)(ptr)
	var objs []MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig
	if obj != nil {
		objs = []MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig)(ptr) = MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig)(ptr) = objs[0]
			} else {
				*(*MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig)(ptr) = MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{}
			}
		} else {
			*(*MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig)(ptr) = MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig)(ptr) = obj
		} else {
			*(*MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig)(ptr) = MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig{}
		}
	default:
		iter.ReportError("decode MonitoringSubscriptionSpecMonitoringSubscriptionRealtimeMetricsSubscriptionConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecCookiesConfigCodec struct {
}

func (OriginRequestPolicySpecCookiesConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecCookiesConfig)(ptr) == nil
}

func (OriginRequestPolicySpecCookiesConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecCookiesConfig)(ptr)
	var objs []OriginRequestPolicySpecCookiesConfig
	if obj != nil {
		objs = []OriginRequestPolicySpecCookiesConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecCookiesConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecCookiesConfig)(ptr) = OriginRequestPolicySpecCookiesConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecCookiesConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecCookiesConfig)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecCookiesConfig)(ptr) = OriginRequestPolicySpecCookiesConfig{}
			}
		} else {
			*(*OriginRequestPolicySpecCookiesConfig)(ptr) = OriginRequestPolicySpecCookiesConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj OriginRequestPolicySpecCookiesConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*OriginRequestPolicySpecCookiesConfig)(ptr) = obj
		} else {
			*(*OriginRequestPolicySpecCookiesConfig)(ptr) = OriginRequestPolicySpecCookiesConfig{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecCookiesConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecCookiesConfigCookiesCodec struct {
}

func (OriginRequestPolicySpecCookiesConfigCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecCookiesConfigCookies)(ptr) == nil
}

func (OriginRequestPolicySpecCookiesConfigCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecCookiesConfigCookies)(ptr)
	var objs []OriginRequestPolicySpecCookiesConfigCookies
	if obj != nil {
		objs = []OriginRequestPolicySpecCookiesConfigCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfigCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecCookiesConfigCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = OriginRequestPolicySpecCookiesConfigCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecCookiesConfigCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfigCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = OriginRequestPolicySpecCookiesConfigCookies{}
			}
		} else {
			*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = OriginRequestPolicySpecCookiesConfigCookies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj OriginRequestPolicySpecCookiesConfigCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfigCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = obj
		} else {
			*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = OriginRequestPolicySpecCookiesConfigCookies{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecCookiesConfigCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecHeadersConfigCodec struct {
}

func (OriginRequestPolicySpecHeadersConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecHeadersConfig)(ptr) == nil
}

func (OriginRequestPolicySpecHeadersConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecHeadersConfig)(ptr)
	var objs []OriginRequestPolicySpecHeadersConfig
	if obj != nil {
		objs = []OriginRequestPolicySpecHeadersConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecHeadersConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecHeadersConfig)(ptr) = OriginRequestPolicySpecHeadersConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecHeadersConfig)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecHeadersConfig)(ptr) = OriginRequestPolicySpecHeadersConfig{}
			}
		} else {
			*(*OriginRequestPolicySpecHeadersConfig)(ptr) = OriginRequestPolicySpecHeadersConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj OriginRequestPolicySpecHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*OriginRequestPolicySpecHeadersConfig)(ptr) = obj
		} else {
			*(*OriginRequestPolicySpecHeadersConfig)(ptr) = OriginRequestPolicySpecHeadersConfig{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecHeadersConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecHeadersConfigHeadersCodec struct {
}

func (OriginRequestPolicySpecHeadersConfigHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) == nil
}

func (OriginRequestPolicySpecHeadersConfigHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecHeadersConfigHeaders)(ptr)
	var objs []OriginRequestPolicySpecHeadersConfigHeaders
	if obj != nil {
		objs = []OriginRequestPolicySpecHeadersConfigHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfigHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecHeadersConfigHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = OriginRequestPolicySpecHeadersConfigHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecHeadersConfigHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfigHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = OriginRequestPolicySpecHeadersConfigHeaders{}
			}
		} else {
			*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = OriginRequestPolicySpecHeadersConfigHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj OriginRequestPolicySpecHeadersConfigHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfigHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = obj
		} else {
			*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = OriginRequestPolicySpecHeadersConfigHeaders{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecHeadersConfigHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecQueryStringsConfigCodec struct {
}

func (OriginRequestPolicySpecQueryStringsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecQueryStringsConfig)(ptr) == nil
}

func (OriginRequestPolicySpecQueryStringsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecQueryStringsConfig)(ptr)
	var objs []OriginRequestPolicySpecQueryStringsConfig
	if obj != nil {
		objs = []OriginRequestPolicySpecQueryStringsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecQueryStringsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = OriginRequestPolicySpecQueryStringsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecQueryStringsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = OriginRequestPolicySpecQueryStringsConfig{}
			}
		} else {
			*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = OriginRequestPolicySpecQueryStringsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj OriginRequestPolicySpecQueryStringsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = obj
		} else {
			*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = OriginRequestPolicySpecQueryStringsConfig{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecQueryStringsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec struct {
}

func (OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) == nil
}

func (OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr)
	var objs []OriginRequestPolicySpecQueryStringsConfigQueryStrings
	if obj != nil {
		objs = []OriginRequestPolicySpecQueryStringsConfigQueryStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfigQueryStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = OriginRequestPolicySpecQueryStringsConfigQueryStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecQueryStringsConfigQueryStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfigQueryStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = OriginRequestPolicySpecQueryStringsConfigQueryStrings{}
			}
		} else {
			*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = OriginRequestPolicySpecQueryStringsConfigQueryStrings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj OriginRequestPolicySpecQueryStringsConfigQueryStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfigQueryStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = obj
		} else {
			*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = OriginRequestPolicySpecQueryStringsConfigQueryStrings{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecQueryStringsConfigQueryStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RealtimeLogConfigSpecEndpointCodec struct {
}

func (RealtimeLogConfigSpecEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RealtimeLogConfigSpecEndpoint)(ptr) == nil
}

func (RealtimeLogConfigSpecEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RealtimeLogConfigSpecEndpoint)(ptr)
	var objs []RealtimeLogConfigSpecEndpoint
	if obj != nil {
		objs = []RealtimeLogConfigSpecEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RealtimeLogConfigSpecEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RealtimeLogConfigSpecEndpoint)(ptr) = RealtimeLogConfigSpecEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RealtimeLogConfigSpecEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RealtimeLogConfigSpecEndpoint)(ptr) = objs[0]
			} else {
				*(*RealtimeLogConfigSpecEndpoint)(ptr) = RealtimeLogConfigSpecEndpoint{}
			}
		} else {
			*(*RealtimeLogConfigSpecEndpoint)(ptr) = RealtimeLogConfigSpecEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RealtimeLogConfigSpecEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RealtimeLogConfigSpecEndpoint)(ptr) = obj
		} else {
			*(*RealtimeLogConfigSpecEndpoint)(ptr) = RealtimeLogConfigSpecEndpoint{}
		}
	default:
		iter.ReportError("decode RealtimeLogConfigSpecEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec struct {
}

func (RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) == nil
}

func (RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr)
	var objs []RealtimeLogConfigSpecEndpointKinesisStreamConfig
	if obj != nil {
		objs = []RealtimeLogConfigSpecEndpointKinesisStreamConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpointKinesisStreamConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = RealtimeLogConfigSpecEndpointKinesisStreamConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RealtimeLogConfigSpecEndpointKinesisStreamConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpointKinesisStreamConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = objs[0]
			} else {
				*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = RealtimeLogConfigSpecEndpointKinesisStreamConfig{}
			}
		} else {
			*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = RealtimeLogConfigSpecEndpointKinesisStreamConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RealtimeLogConfigSpecEndpointKinesisStreamConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpointKinesisStreamConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = obj
		} else {
			*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = RealtimeLogConfigSpecEndpointKinesisStreamConfig{}
		}
	default:
		iter.ReportError("decode RealtimeLogConfigSpecEndpointKinesisStreamConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecCorsConfigCodec struct {
}

func (ResponseHeadersPolicySpecCorsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecCorsConfig)(ptr) == nil
}

func (ResponseHeadersPolicySpecCorsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecCorsConfig)(ptr)
	var objs []ResponseHeadersPolicySpecCorsConfig
	if obj != nil {
		objs = []ResponseHeadersPolicySpecCorsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecCorsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecCorsConfig)(ptr) = ResponseHeadersPolicySpecCorsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecCorsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecCorsConfig)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecCorsConfig)(ptr) = ResponseHeadersPolicySpecCorsConfig{}
			}
		} else {
			*(*ResponseHeadersPolicySpecCorsConfig)(ptr) = ResponseHeadersPolicySpecCorsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecCorsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecCorsConfig)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecCorsConfig)(ptr) = ResponseHeadersPolicySpecCorsConfig{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecCorsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeadersCodec struct {
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders)(ptr) == nil
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders)(ptr)
	var objs []ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders
	if obj != nil {
		objs = []ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{}
			}
		} else {
			*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecCorsConfigAccessControlAllowHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethodsCodec struct {
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethodsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods)(ptr) == nil
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethodsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods)(ptr)
	var objs []ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods
	if obj != nil {
		objs = []ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethodsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{}
			}
		} else {
			*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecCorsConfigAccessControlAllowMethods", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecCorsConfigAccessControlAllowOriginsCodec struct {
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlAllowOriginsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins)(ptr) == nil
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlAllowOriginsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins)(ptr)
	var objs []ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins
	if obj != nil {
		objs = []ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlAllowOriginsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{}
			}
		} else {
			*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecCorsConfigAccessControlAllowOrigins", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeadersCodec struct {
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders)(ptr) == nil
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders)(ptr)
	var objs []ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders
	if obj != nil {
		objs = []ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{}
			}
		} else {
			*(*ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders)(ptr) = ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecCorsConfigAccessControlExposeHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecCustomHeadersConfigCodec struct {
}

func (ResponseHeadersPolicySpecCustomHeadersConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecCustomHeadersConfig)(ptr) == nil
}

func (ResponseHeadersPolicySpecCustomHeadersConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecCustomHeadersConfig)(ptr)
	var objs []ResponseHeadersPolicySpecCustomHeadersConfig
	if obj != nil {
		objs = []ResponseHeadersPolicySpecCustomHeadersConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCustomHeadersConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecCustomHeadersConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecCustomHeadersConfig)(ptr) = ResponseHeadersPolicySpecCustomHeadersConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecCustomHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCustomHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecCustomHeadersConfig)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecCustomHeadersConfig)(ptr) = ResponseHeadersPolicySpecCustomHeadersConfig{}
			}
		} else {
			*(*ResponseHeadersPolicySpecCustomHeadersConfig)(ptr) = ResponseHeadersPolicySpecCustomHeadersConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecCustomHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecCustomHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecCustomHeadersConfig)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecCustomHeadersConfig)(ptr) = ResponseHeadersPolicySpecCustomHeadersConfig{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecCustomHeadersConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecSecurityHeadersConfigCodec struct {
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecSecurityHeadersConfig)(ptr) == nil
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecSecurityHeadersConfig)(ptr)
	var objs []ResponseHeadersPolicySpecSecurityHeadersConfig
	if obj != nil {
		objs = []ResponseHeadersPolicySpecSecurityHeadersConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecSecurityHeadersConfig)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecSecurityHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfig)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfig)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfig{}
			}
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfig)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecSecurityHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecSecurityHeadersConfig)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfig)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfig{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecSecurityHeadersConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicyCodec struct {
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy)(ptr) == nil
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy)(ptr)
	var objs []ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy
	if obj != nil {
		objs = []ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{}
			}
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecSecurityHeadersConfigContentSecurityPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptionsCodec struct {
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions)(ptr) == nil
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions)(ptr)
	var objs []ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions
	if obj != nil {
		objs = []ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{}
			}
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecSecurityHeadersConfigContentTypeOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptionsCodec struct {
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions)(ptr) == nil
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions)(ptr)
	var objs []ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions
	if obj != nil {
		objs = []ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{}
			}
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecSecurityHeadersConfigFrameOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicyCodec struct {
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy)(ptr) == nil
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy)(ptr)
	var objs []ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy
	if obj != nil {
		objs = []ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{}
			}
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecSecurityHeadersConfigReferrerPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurityCodec struct {
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity)(ptr) == nil
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity)(ptr)
	var objs []ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity
	if obj != nil {
		objs = []ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{}
			}
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecSecurityHeadersConfigStrictTransportSecurity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResponseHeadersPolicySpecSecurityHeadersConfigXssProtectionCodec struct {
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigXssProtectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection)(ptr) == nil
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigXssProtectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection)(ptr)
	var objs []ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection
	if obj != nil {
		objs = []ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResponseHeadersPolicySpecSecurityHeadersConfigXssProtectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection)(ptr) = objs[0]
			} else {
				*(*ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{}
			}
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection)(ptr) = obj
		} else {
			*(*ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection)(ptr) = ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection{}
		}
	default:
		iter.ReportError("decode ResponseHeadersPolicySpecSecurityHeadersConfigXssProtection", "unexpected JSON type")
	}
}
